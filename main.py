import sys, os, json, re, anthropic, uuid, json, shutil
from datetime import datetime
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QDialogButtonBox, QHeaderView, QTableWidget, 
                             QPushButton, QFileDialog, QInputDialog, QLabel, QTableWidgetItem, QTabWidget, 
                             QSplitter, QFrame, QSizePolicy, QTreeWidget, QTreeWidgetItem, QCheckBox,
                             QScrollArea, QLineEdit, QFormLayout, QProgressDialog, QComboBox, QButtonGroup, QMessageBox,
                             QDialog, QTextEdit, QListWidgetItem, QListWidget)
from PyQt6.QtCore import Qt, QTimer, QSettings
from PyQt6.QtGui import QIcon, QKeySequence, QShortcut

class BulkTestCaseDialog(QDialog):
    def __init__(self, parent=None, checklist=None):
        super().__init__(parent)
        self.checklist = checklist or []
        self.setWindowTitle("Add Bulk Test Cases")
        self.layout = QVBoxLayout(self)

        self.test_case_combo = QComboBox()
        self.test_case_combo.addItems([item.split(':', 1)[0] for item in self.checklist])
        self.test_case_combo.setEditable(True)
        self.layout.addWidget(QLabel("Test Case:"))
        self.layout.addWidget(self.test_case_combo)

        self.technique_edit = QLineEdit()
        self.layout.addWidget(QLabel("Technique:"))
        self.layout.addWidget(self.technique_edit)

        self.test_case_combo.currentIndexChanged.connect(self.update_technique)

        self.asset_edit = QLineEdit()
        self.layout.addWidget(QLabel("asset:"))
        self.layout.addWidget(self.asset_edit)

        self.locations_edit = QTextEdit()
        self.layout.addWidget(QLabel("Locations (one per line):"))
        self.layout.addWidget(self.locations_edit)

        self.comment_edit = QLineEdit()
        self.layout.addWidget(QLabel("Comment:"))
        self.layout.addWidget(self.comment_edit)

        self.outcome_edit = QLineEdit()
        self.layout.addWidget(QLabel("Outcome:"))
        self.layout.addWidget(self.outcome_edit)

        self.priority_checkbox = QCheckBox("High Priority")
        self.layout.addWidget(self.priority_checkbox)

        self.buttons = QHBoxLayout()
        self.ok_button = QPushButton("OK")
        self.cancel_button = QPushButton("Cancel")
        self.buttons.addWidget(self.ok_button)
        self.buttons.addWidget(self.cancel_button)
        self.layout.addLayout(self.buttons)

        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

    def update_technique(self, index):
        if 0 <= index < len(self.checklist):
            parts = self.checklist[index].split(':', 1)
            if len(parts) > 1:
                self.technique_edit.setText(parts[1].strip())
            else:
                self.technique_edit.clear()
        else:
            self.technique_edit.clear()

    def get_data(self):
        return {
            'test_case': self.test_case_combo.currentText(),
            'technique': self.technique_edit.text(),
            'asset': self.asset_edit.text(),
            'locations': self.locations_edit.toPlainText().split('\n'),
            'comment': self.comment_edit.text(),
            'outcome': self.outcome_edit.text(),
            'high_priority': self.priority_checkbox.isChecked()
        }

class TestCaseBox(QFrame):
    def __init__(self, test_case_data, test_cases, workspace, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.test_case_data = test_case_data
        self.workspace = workspace
        self.setFrameStyle(QFrame.Shape.Box | QFrame.Shadow.Raised)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        
        self.setStyleSheet("""
            TestCaseBox {
                background-color: #555555;
                border: 1px #555555;
                border-radius: 5px;
            }
        """)
        
        main_layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        main_layout.addLayout(form_layout)
        
        self.fields = {}
        
        for field, value in test_case_data.items():
            if field not in ['created_at', 'completed_at', 'status', 'id', 'exported', 'module', 'report_exported', 'report_submitted', 'high_priority']:
                line_edit = QLineEdit(str(value))
                if field == 'asset':
                    field_name = self.get_asset_field_name()
                else:
                    field_name = field.capitalize()
                line_edit.setPlaceholderText(field_name)
                form_layout.addRow(line_edit)
                self.fields[field] = line_edit
        
        bottom_layout = QHBoxLayout()
        bottom_layout.addStretch(1)
        
        copy_button = QPushButton("")
        copy_button.setIcon(QIcon.fromTheme('edit-copy'))
        copy_button.clicked.connect(self.copy_test_case)
        copy_button.setToolTip('Copy test case')
        # copy_button.setFixedWidth(80)
        bottom_layout.addWidget(copy_button)
        
        self.status_button_group = QButtonGroup(self)
        self.not_started_button = QPushButton("Not Started")
        self.not_started_button.setToolTip('Not Started')
        self.on_going_button = QPushButton("On-Going")
        self.on_going_button.setToolTip('On-Going')
        self.pass_button = QPushButton("Pass")
        self.pass_button.setToolTip('Pass')
        self.pass_button.setIcon(QIcon.fromTheme(''))
        self.fail_button = QPushButton("Fail")
        self.fail_button.setToolTip('Fail')

        self.not_started_button.setCheckable(True)
        self.on_going_button.setCheckable(True)
        self.pass_button.setCheckable(True)
        self.fail_button.setCheckable(True)

        self.status_button_group.addButton(self.not_started_button)
        self.status_button_group.addButton(self.on_going_button)
        self.status_button_group.addButton(self.pass_button)
        self.status_button_group.addButton(self.fail_button)
        
        bottom_layout.addWidget(self.not_started_button)
        bottom_layout.addWidget(self.on_going_button)
        bottom_layout.addWidget(self.pass_button)
        bottom_layout.addWidget(self.fail_button)
        
        status = test_case_data.get('status', "Not Started")
        if status == "Not Started":
            self.not_started_button.setChecked(True)
        elif status == "On-Going":
            self.on_going_button.setChecked(True)
        elif status == "Pass":
            self.pass_button.setChecked(True)
        elif status == "Fail":
            self.fail_button.setChecked(True)
        
        self.status_button_group.buttonClicked.connect(self.on_status_changed)
        
        # Add export checkbox
        self.export_checkbox = QCheckBox("Exported")
        self.export_checkbox.setChecked(test_case_data.get('exported', False))
        self.export_checkbox.stateChanged.connect(self.on_export_changed)
        bottom_layout.addWidget(self.export_checkbox)

        self.priority_checkbox = QCheckBox("High Priority")
        self.priority_checkbox.setChecked(test_case_data.get('high_priority', False))
        self.priority_checkbox.stateChanged.connect(self.on_priority_changed)
        bottom_layout.addWidget(self.priority_checkbox)
        # form_layout.addRow(self.priority_checkbox)

        save_button = QPushButton("")
        save_button.clicked.connect(self.save_changes)
        save_button.setIcon(QIcon.fromTheme('document-save'))
        save_button.setToolTip('Save testcase')
        # save_button.setFixedWidth(60)
        bottom_layout.addWidget(save_button)
        
        self.delete_button = QPushButton("")
        self.delete_button.setIcon(QIcon.fromTheme('edit-delete'))
        self.delete_button.clicked.connect(self.delete_test_case)
        self.delete_button.setToolTip('Delete testcase')
        # self.delete_button.setFixedWidth(60)
        bottom_layout.addWidget(self.delete_button)

        # Add keyboard shortcut for opening current workspace dir
        # save_all_shortcut = QShortcut(QKeySequence("Alt+P"), self)
        # save_all_shortcut.activated.connect(self.)

        main_layout.addLayout(bottom_layout)
        self.update_appearance()

    def get_asset_field_name(self):
        asset_type = self.parent.asset_type if self.parent else 'Web app'
        asset_field_names = {
            'Web app': 'URL',
            'API': 'Endpoint',
            'Network': 'IP',
            'Source code review': 'File path',
            'Android': 'Asset'
        }
        return asset_field_names.get(asset_type, 'Asset')

    def on_priority_changed(self, state):
        self.test_case_data['high_priority'] = state == Qt.CheckState.Checked.value
        self.save_changes()

    def update_appearance(self):
        if self.test_case_data['status'] == "Pass":
            self.setStyleSheet("""
                TestCaseBox {
                    background-color: #90EE90;  /* Light green */
                    border: 1px solid #2E8B57;  /* Dark green border */
                    border-radius: 5px;
                }
            """)
        elif self.test_case_data['status'] == "Fail":
            self.setStyleSheet("""
                TestCaseBox {
                    background-color: #FFB6C1;  /* Light red */
                    border: 1px solid #B22222;  /* Dark red border */
                    border-radius: 5px;
                }
            """)
        elif self.test_case_data['status'] == "On-Going":
            self.setStyleSheet("""
                TestCaseBox {
                    background-color: #FFFACD;  /* Light yellow */
                    border: 1px solid #DAA520;  /* Golden border */
                    border-radius: 5px;
                }
            """)
        else:  # Not Started
            self.setStyleSheet("""
                TestCaseBox {
                    background-color: #E6E6FA;  /* Light gray */
                    border: 1px solid #A9A9A9;  /* Dark gray border */
                    border-radius: 5px;
                }
            """)
        if self.test_case_data.get('high_priority', False):
            self.setStyleSheet(self.styleSheet() + """
                TestCaseBox {
                    border: 2px solid #FF4500;  /* Orange-Red border for high priority */
                }
            """)
        self.export_checkbox.setStyleSheet("color: black;")
        self.priority_checkbox.setStyleSheet("color: black;")

    def save_current_values(self):
        for field, widget in self.fields.items():
            if isinstance(widget, QComboBox):
                self.test_case_data[field] = widget.currentText()
            else:
                self.test_case_data[field] = widget.text()
        
        self.test_case_data['status'] = self.get_current_status()
        self.test_case_data['exported'] = self.export_checkbox.isChecked()
        
        if self.parent:
            self.parent.save_test_case(self.test_case_data)

    def get_current_status(self):
        if self.not_started_button.isChecked():
            return "Not Started"
        elif self.on_going_button.isChecked():
            return "On-Going"
        elif self.pass_button.isChecked():
            return "Pass"
        elif self.fail_button.isChecked():
            return "Fail"
        else:
            return "Not Started"  # Default status

    def on_export_changed(self, state):
        self.test_case_data['exported'] = state == Qt.CheckState.Checked.value
        self.save_changes()

    def copy_test_case(self):
        self.save_current_values()  # Save current values before copying
        new_test_case = self.test_case_data.copy()
        new_test_case['test case'] = f"{new_test_case['test case']}"
        new_test_case['created_at'] = datetime.now().isoformat()
        new_test_case['completed_at'] = None
        new_test_case['status'] = "Not Started"
        new_test_case['id'] = str(uuid.uuid4())  # Generate a new unique ID for the copy
        new_test_case['exported'] = False  # Set exported status to False for the copy
        
        if self.parent:
            self.parent.add_copied_test_case(new_test_case)

    def delete_test_case(self):
        if self.parent and self.parent.delete_mode:
            self.parent.delete_test_case(self.test_case_data['id'])
        else:
            reply = QMessageBox.question(self, 'Delete Test Case',
                                         f"Are you sure you want to delete the test case '{self.test_case_data['test case']}'?",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                         QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.Yes:
                self.parent.delete_test_case(self.test_case_data['id'])  

    def on_status_changed(self, button):
        new_status = self.get_current_status()
        if new_status in ["Pass", "Fail"]:
            self.test_case_data['completed_at'] = datetime.now().isoformat()
        else:
            self.test_case_data['completed_at'] = ""  # Empty string instead of None
        self.test_case_data['status'] = new_status
        self.update_appearance()
        self.save_changes()

    def save_changes(self):
        for field, widget in self.fields.items():
            if isinstance(widget, QComboBox):
                self.test_case_data[field] = widget.currentText()
            else:
                self.test_case_data[field] = widget.text()
        
        self.test_case_data['status'] = self.get_current_status()
        if self.test_case_data['status'] in ["Pass", "Fail"]:
            if not self.test_case_data.get('completed_at'):
                self.test_case_data['completed_at'] = datetime.now().isoformat()
        else:
            self.test_case_data['completed_at'] = ""  # Empty string instead of None
        
        self.test_case_data['high_priority'] = self.priority_checkbox.isChecked()
        self.test_case_data['exported'] = bool(self.export_checkbox.isChecked())
        self.test_case_data['report_exported'] = bool(self.test_case_data.get('report_exported', False))
        self.test_case_data['report_submitted'] = bool(self.test_case_data.get('report_submitted', False))
        
        self.update_appearance()
        
        if self.parent:
            self.parent.save_test_case(self.test_case_data)
            self.parent.update_project_stats()
            self.parent.update_issues_tab()

class ProjectManager(QMainWindow):
    def __init__(self):
        super().__init__()
        self.workspace = None
        self.project_name = None
        self.project_day = None
        self.current_module_name = None
        self.delete_mode = False
        self.exportable_count = 0
        self.asset_type = None
        self.current_view = 'module'  # Can be 'module' or 'filtered'
        self.settings = QSettings("YourCompany", "ProjectManager")
        self.checklist = []
        
        self.initUI()
        
        # Set up autosave timer
        self.autosave_timer = QTimer(self)
        self.autosave_timer.timeout.connect(self.autosave)
        self.autosave_timer.start(60000)  # 1000 ms = 1 second

        # Set up snapshot timer
        self.snapshot_timer = QTimer(self)
        self.snapshot_timer.timeout.connect(self.create_snapshot)
        self.snapshot_timer.start(60000)  # 60000 ms = 1 minutes

        # Maximize the window
        self.showMaximized()

        # Show recent projects dialog
        selected_project = self.show_recent_projects_dialog()
        if selected_project:
            self.workspace = selected_project
            self.load_project()
        else:
            self.close()  # Close the application if no project is selected

        # Apply the saved theme or default to system theme
        self.apply_theme(self.settings.value("theme", "system"))

        print("\n######################################\n Project Manager\n######################################\n")

    def load_project(self):
        try:
            self.checkLogFile()
            self.loadModules()
            self.load_last_module()
            self.update_project_stats()
            self.update_issues_tab()
            
            # Update recent projects list
            recent_projects = self.settings.value("recent_projects", [])
            current_project = {"name": self.project_name, "path": self.workspace}
            if current_project in recent_projects:
                recent_projects.remove(current_project)
            recent_projects.insert(0, current_project)
            recent_projects = recent_projects[:5]  # Keep only the 5 most recent projects
            self.settings.setValue("recent_projects", recent_projects)
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Error loading project: {str(e)}")
            self.close()

    def show_recent_projects_dialog(self):
        dialog = QDialog(self)
        dialog.setWindowTitle("Recent Projects")
        layout = QVBoxLayout(dialog)

        # Load recent projects from settings
        settings = QSettings("YourCompany", "ProjectManager")
        recent_projects = settings.value("recent_projects", [])

        if recent_projects:
            list_widget = QListWidget()
            for project in recent_projects:
                item = QListWidgetItem(f"{project['name']} - {project['path']}")
                item.setData(Qt.ItemDataRole.UserRole, project['path'])
                list_widget.addItem(item)
            layout.addWidget(list_widget)

            open_btn = QPushButton("Open")
            open_btn.clicked.connect(lambda: dialog.done(1))
            layout.addWidget(open_btn)

            remove_btn = QPushButton("Remove")
            remove_btn.clicked.connect(lambda: self.remove_selected_project(list_widget, recent_projects))
            layout.addWidget(remove_btn)

        new_project_btn = QPushButton("New Project")
        new_project_btn.clicked.connect(lambda: dialog.done(2))
        layout.addWidget(new_project_btn)

        result = dialog.exec()

        if result == 1 and recent_projects:  # Open selected project
            selected_item = list_widget.currentItem()
            if selected_item:
                return selected_item.data(Qt.ItemDataRole.UserRole)
        elif result == 2:  # Create new project
            return self.selectFolder()
        
        return None

    def remove_selected_project(self, list_widget, recent_projects):
        selected_item = list_widget.currentItem()
        if selected_item:
            project_path = selected_item.data(Qt.ItemDataRole.UserRole)
            recent_projects = [p for p in recent_projects if p['path'] != project_path]
            self.settings.setValue("recent_projects", recent_projects)
            list_widget.takeItem(list_widget.row(selected_item))

    def create_snapshot(self):
        if not self.workspace:
            return

        print("\n######################################\nSaving project snapshot\n######################################\n")

        snapshot_dir = os.path.join(self.workspace, 'snapshots')
        os.makedirs(snapshot_dir, exist_ok=True)

        timestamp = datetime.now().strftime('%d-%m-%Y_%H-%M-%S')
        snapshot_file = os.path.join(snapshot_dir, f'snapshot_{timestamp}.json')

        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            shutil.copy2(module_file, snapshot_file)

        # Keep only the last 10 snapshots
        snapshots = sorted(os.listdir(snapshot_dir), reverse=True)
        for old_snapshot in snapshots[10:]:
            os.remove(os.path.join(snapshot_dir, old_snapshot))

    def setup_action_buttons(self):
        action_layout = QHBoxLayout()
        
        refresh_button = QPushButton("Refresh")
        refresh_button.clicked.connect(self.refresh_test_cases)
        action_layout.addWidget(refresh_button)

        reverse_button = QPushButton("Reverse")
        reverse_button.clicked.connect(self.reverse_test_cases)
        action_layout.addWidget(reverse_button)

        priority_button = QPushButton("Priority")
        priority_button.clicked.connect(self.sort_by_priority)
        action_layout.addWidget(priority_button)

        action_layout.addStretch()
        return action_layout

    def reverse_test_cases(self):
        if self.current_view == 'module':
            self.reverse_module_test_cases()
        else:
            self.reverse_filtered_test_cases()

    def sort_by_priority(self):
        if self.current_view == 'module':
            self.sort_module_by_priority()
        else:
            self.sort_filtered_by_priority()

    def refresh_module_test_cases(self):
        module_file = os.path.join(self.workspace, 'modules.json')
        with open(module_file, 'r') as f:
            modules = json.load(f)
        
        current_module = self.current_module
        if current_module in modules:
            test_cases = modules[current_module]['test_cases']
            
            # Separate test cases by status
            ongoing_not_started = [tc for tc in test_cases if tc['status'] in ["On-Going", "Not Started"]]
            others = [tc for tc in test_cases if tc['status'] not in ["On-Going", "Not Started"]]
            
            # Combine the lists and update the module
            modules[current_module]['test_cases'] = ongoing_not_started + others
            
            # Save the updated modules
            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)
            
            # Refresh the display
            self.display_test_cases(current_module)

    def refresh_module_test_cases(self):
        module_file = os.path.join(self.workspace, 'modules.json')
        with open(module_file, 'r') as f:
            modules = json.load(f)
        
        current_module = self.current_module
        if current_module in modules:
            test_cases = modules[current_module]['test_cases']
            
            # Separate test cases by status
            ongoing_not_started = [tc for tc in test_cases if tc['status'] in ["On-Going", "Not Started"]]
            others = [tc for tc in test_cases if tc['status'] not in ["On-Going", "Not Started"]]
            
            # Combine the lists and update the module
            modules[current_module]['test_cases'] = ongoing_not_started + others
            
            # Save the updated modules
            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)
            
            # Refresh the display
            self.display_test_cases(current_module)

    def refresh_filtered_test_cases(self):
        module_name = self.current_module_name
        test_case_name = self.current_module
        self.filter_test_cases(module_name, test_case_name)

    def reverse_module_test_cases(self):
        module_file = os.path.join(self.workspace, 'modules.json')
        with open(module_file, 'r') as f:
            modules = json.load(f)
        
        current_module = self.current_module
        if current_module in modules:
            test_cases = modules[current_module]['test_cases']
            
            # Separate test cases by status
            ongoing_not_started = [tc for tc in test_cases if tc['status'] in ["On-Going", "Not Started"]]
            others = [tc for tc in test_cases if tc['status'] not in ["On-Going", "Not Started"]]
            
            # Reverse the order of ongoing and not started test cases
            ongoing_not_started.reverse()
            
            # Combine the lists and update the module
            modules[current_module]['test_cases'] = ongoing_not_started + others
            
            # Save the updated modules
            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)
            
            # Refresh the display
            self.display_test_cases(current_module)

    def reverse_filtered_test_cases(self):
        module_name = self.current_module_name
        test_case_name = self.current_module
        module_file = os.path.join(self.workspace, 'modules.json')
        with open(module_file, 'r') as f:
            modules = json.load(f)
        
        if module_name in modules:
            test_cases = modules[module_name]['test_cases']
            filtered_test_cases = [tc for tc in test_cases if tc['test case'] == test_case_name]
            filtered_test_cases.reverse()
            
            # Update the original test cases list
            for i, tc in enumerate(test_cases):
                if tc['test case'] == test_case_name:
                    test_cases[i] = filtered_test_cases.pop(0)
            
            modules[module_name]['test_cases'] = test_cases
            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)
            
            self.filter_test_cases(module_name, test_case_name)

    def sort_module_by_priority(self):
        module_file = os.path.join(self.workspace, 'modules.json')
        with open(module_file, 'r') as f:
            modules = json.load(f)
        
        current_module = self.current_module
        if current_module in modules:
            test_cases = modules[current_module]['test_cases']
            
            # Separate test cases by status and priority
            high_priority = [tc for tc in test_cases if tc['status'] in ["On-Going", "Not Started"] and tc.get('high_priority', False)]
            normal_priority = [tc for tc in test_cases if tc['status'] in ["On-Going", "Not Started"] and not tc.get('high_priority', False)]
            others = [tc for tc in test_cases if tc['status'] not in ["On-Going", "Not Started"]]
            
            # Combine the lists and update the module
            modules[current_module]['test_cases'] = high_priority + normal_priority + others
            
            # Save the updated modules
            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)
            
            # Refresh the display
            self.display_test_cases(current_module)

    def sort_filtered_by_priority(self):
        module_name = self.current_module_name
        test_case_name = self.current_module
        module_file = os.path.join(self.workspace, 'modules.json')
        with open(module_file, 'r') as f:
            modules = json.load(f)
        
        if module_name in modules:
            test_cases = modules[module_name]['test_cases']
            filtered_test_cases = [tc for tc in test_cases if tc['test case'] == test_case_name]
            
            high_priority = [tc for tc in filtered_test_cases if tc['status'] in ["On-Going", "Not Started"] and tc.get('high_priority', False)]
            normal_priority = [tc for tc in filtered_test_cases if tc['status'] in ["On-Going", "Not Started"] and not tc.get('high_priority', False)]
            others = [tc for tc in filtered_test_cases if tc['status'] not in ["On-Going", "Not Started"]]
            
            sorted_filtered_test_cases = high_priority + normal_priority + others
            
            # Update the original test cases list
            for i, tc in enumerate(test_cases):
                if tc['test case'] == test_case_name:
                    test_cases[i] = sorted_filtered_test_cases.pop(0)
            
            modules[module_name]['test_cases'] = test_cases
            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)
            
            self.filter_test_cases(module_name, test_case_name)

    def save_current_module(self):
        if self.current_module and self.workspace:
            log_file = os.path.join(self.workspace, 'module_log.txt')
            with open(log_file, 'w') as f:
                f.write(self.current_module)

    def load_last_module(self):
        if self.workspace:
            log_file = os.path.join(self.workspace, 'module_log.txt')
            if os.path.exists(log_file):
                with open(log_file, 'r') as f:
                    last_module = f.read().strip()
                if last_module:
                    self.select_module(last_module)

    def select_module(self, module_name):
        for i in range(self.module_tree.topLevelItemCount()):
            item = self.module_tree.topLevelItem(i)
            if item.data(0, Qt.ItemDataRole.UserRole) == module_name:
                self.module_tree.setCurrentItem(item)
                self.on_module_clicked(item, 0)
                break

    def load_checklist(self):
        if not self.workspace:
            QMessageBox.warning(self, "Warning", "Please select a workspace first.")
            return

        file_path, _ = QFileDialog.getOpenFileName(self, "Select Checklist File", "", "Text Files (*.txt)")
        if file_path:
            try:
                self.load_checklist_from_path(file_path)
                self.checklist_path = file_path  # Save the path
                self.saveProjectInfo()  # Update the project log with the new path
                QMessageBox.information(self, "Checklist Loaded", "Checklist has been loaded successfully.")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"An error occurred while loading the checklist: {str(e)}")

    def update_checklist(self):
        checklist_file = os.path.join(self.workspace, 'checklist.txt')
        if os.path.exists(checklist_file):
            with open(checklist_file, 'r') as f:
                self.checklist = [line.strip() for line in f if line.strip()]
        else:
            self.checklist = []

    def autoSelectWorkspace(self):
        # Check if there's a last used workspace
        self.clear_test_case_display()  
        settings = QSettings("YourCompany", "ProjectManager")
        last_workspace = settings.value("last_workspace", "")

        if last_workspace and os.path.exists(last_workspace):
            self.workspace = last_workspace
            try:
                self.checkLogFile()
                self.loadModules()
                self.load_last_module()  # Load the last selected module
                self.update_project_stats()
                self.update_issues_tab()
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Error loading last workspace: {str(e)}")
                self.selectFolder()
        else:
            self.selectFolder()

    def anonymize_assets(self, content):
        asset_pattern = re.compile(r'\*\*(.*?)\*\*')
        placeholders = {}
        
        def replace_asset(match):
            asset = match.group(1)
            placeholder = "{asset}" + f'_{len(placeholders)}'
            placeholders[placeholder] = asset
            return placeholder
        
        anonymized_content = asset_pattern.sub(replace_asset, content)
        return anonymized_content, placeholders

    def process_with_anthropic(self, content, prompt):
        client = anthropic.Anthropic(api_key=os.environ.get('ANTHROPIC_API_KEY'))
        full_prompt = f"{prompt}\n\n{content}"
        message = client.messages.create(
            model="claude-3-5-sonnet-20240620",
            max_tokens=1000,
            temperature=0,
            messages=[
                {
                    "role": "user",
                    "content": full_prompt
                }
            ]
        )
        processed_content = message.content[0].text
        return processed_content

    def reinsert_assets(self, content, placeholders):
        for placeholder, asset in placeholders.items():
            content = content.replace(placeholder, f"{asset}")
        content = re.sub(r'\n\n+', '\n', content)
        return content

    def write_and_process(self):
        if not self.workspace:
            QMessageBox.warning(self, "Error", "Please select a workspace first.")
            return

        try:
            # Get the list of exported folders
            export_folder = os.path.join(self.workspace, 'Exported')
            exported_folders = [f for f in os.listdir(export_folder) if os.path.isdir(os.path.join(export_folder, f))]

            if not exported_folders:
                QMessageBox.warning(self, "Error", "No exported folders found.")
                return

            # Let user select an exported folder or file
            selected_item, ok = QInputDialog.getItem(self, "Select Exported Item", "Choose a folder or file:", exported_folders, 0, False)
            if not ok:
                return

            selected_path = os.path.join(export_folder, selected_item)

            # Process the selected item
            if os.path.isdir(selected_path):
                # Process all files in the selected folder
                files_to_process = [f for f in os.listdir(selected_path) if f.endswith('.txt')]
                all_processed_content = ""
                for file in files_to_process:
                    file_path = os.path.join(selected_path, file)
                    with open(file_path, 'r') as f:
                        content = f.read()
                    processed_content = self.process_single_file(content)
                    all_processed_content += processed_content + "\n\n"
            else:
                # Process the single selected file
                with open(selected_path, 'r') as f:
                    content = f.read()
                all_processed_content = self.process_single_file(content)

            # Save the output
            updates_folder = os.path.join(self.workspace, 'Updates')
            os.makedirs(updates_folder, exist_ok=True)
            output_folder = f"{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}_{len(all_processed_content.split('Entry'))}"
            output_path = os.path.join(updates_folder, output_folder)
            os.makedirs(output_path, exist_ok=True)
            output_file = f"update.txt"
            output_file_path = os.path.join(output_path, output_file)

            with open(output_file_path, 'w') as f:
                f.write(all_processed_content)

            QMessageBox.information(self, "Success", f"Processed content saved to {output_file_path}")
            os.startfile(output_path)

        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred during processing: {str(e)}")
            print(f"Error in write_and_process: {str(e)}")

    def process_single_file(self, content):
        # Anonymize assets
        anonymized_content, placeholders = self.anonymize_assets(content)

        # Get prompts from the prompts folder
        prompts_folder = os.path.join(os.path.dirname(__file__), 'prompts')
        prompts = [f for f in os.listdir(prompts_folder) if f.endswith('.txt')]

        if not prompts:
            raise Exception("No prompts found in the prompts folder.")

        # Manually setting web.txt as default prompt input for the LLM
        # CHANGE ME DEFAULT PROMPT FILE BELOW
        prompt = os.path.join(os.path.dirname(__file__), r'prompts\web.txt')

        # Let user select a prompt
        # UNCOMMENT ME TO PERFORM PROMPT SELECTION
        # prompt, ok = QInputDialog.getItem(self, "Select Prompt", "Choose a prompt:", prompts, 0, False)
        # if not ok:
            # raise Exception("Prompt selection cancelled.")

        # Read the selected prompt
        with open(os.path.join(prompts_folder, prompt), 'r') as f:
            prompt_content = f.read()

        # print("")
        # print(anonymized_content)
        # print("")
        # Process with Anthropic
        processed_content = self.process_with_anthropic(anonymized_content, prompt_content)

        # Reinsert assets
        final_content = self.reinsert_assets(processed_content, placeholders)

        return final_content

    def add_copied_test_case(self, new_test_case):
        current_item = self.module_tree.currentItem()
        if current_item:
            module_name = current_item.data(0, Qt.ItemDataRole.UserRole)
            self.save_modules(new_data=new_test_case, current_module_name=module_name)
            self.display_test_cases(module_name)  # Refresh the display
            self.update_project_stats()
            self.update_issues_tab()

    def update_project_stats(self):
        if not self.workspace:
            self.project_info_label.setText("No project selected")
            return

        total_cases = 0
        total_completed = 0
        module_file = os.path.join(self.workspace, 'modules.json')
        try:
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)
                
                for module_name, module_data in modules.items():
                    test_cases = module_data['test_cases']
                    cases_count = len(test_cases)
                    completed_count = sum(1 for case in test_cases if case['status'] in ["Pass", "Fail"])
                    total_cases += cases_count
                    total_completed += completed_count
                    
                    if cases_count == 0:
                        completion_percentage = 100
                    else:
                        completion_percentage = round((completed_count / cases_count) * 100, 1)

                    module_item = self.find_module_item(module_name)
                    if module_item:
                        module_item.setText(0, f"{module_name} ({completion_percentage:.1f}%)")
                        module_item.setData(0, Qt.ItemDataRole.UserRole, module_name)
            
            if total_cases > 0:
                project_completion = round((total_completed / total_cases) * 100, 1)
            else:
                project_completion = 0
            
            self.update_header_info(total_cases, total_completed, project_completion)
            self.refresh_module_tree()
        except Exception as e:
            print(f"Error updating project stats: {str(e)}")
            self.project_info_label.setText("Error updating project stats")

    def refresh_module_tree(self):
        for i in range(self.module_tree.topLevelItemCount()):
            item = self.module_tree.topLevelItem(i)
            module_name = item.data(0, Qt.ItemDataRole.UserRole)
            self.update_module_percentage(item, module_name)

    def update_module_percentage(self, item, module_name):
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            if module_name in modules:
                test_cases = modules[module_name]['test_cases']
                cases_count = len(test_cases)
                completed_count = sum(1 for case in test_cases if case['status'] in ["Pass", "Fail"])
                
                if cases_count == 0:
                    completion_percentage = 100
                else:
                    completion_percentage = round((completed_count / cases_count) * 100, 1)

                item.setText(0, f"{module_name} | {completion_percentage:.1f}% | [{completed_count}/{cases_count}]")


    def find_module_item(self, module_name):
        for i in range(self.module_tree.topLevelItemCount()):
            item = self.module_tree.topLevelItem(i)
            if item.data(0, Qt.ItemDataRole.UserRole) == module_name:
                return item
        return None

    def update_header_info(self, total_cases, total_completed, project_completion):
        today = datetime.now().date()
        completed_today = self.get_completed_today()
        self.exportable_count = self.get_exportable_count()
        
        header_text = (f"{today.strftime('%Y-%m-%d')} | "
                       f"{project_completion:.1f}% | "
                       f"Completed today: {completed_today}")
        
        self.project_info_label.setText(header_text)
        self.exportable_label.setText(f"Exportable: {self.exportable_count}")

    def get_exportable_count(self):
        exportable_count = 0
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            for module_name, module_data in modules.items():
                test_cases = module_data['test_cases']
                exportable_count += sum(1 for case in test_cases if case['status'] in ["Pass", "Fail"] and not case.get('exported', False))
        
        return exportable_count

    def get_completed_today(self):
        today = datetime.now().date()
        completed_today = 0
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            for module_name, module_data in modules.items():
                test_cases = module_data['test_cases']
                for case in test_cases:
                    if case['status'] in ["Pass", "Fail"] and case['completed_at']:
                        try:
                            completed_date = datetime.fromisoformat(case['completed_at']).date()
                            if completed_date == today:
                                completed_today += 1
                        except (ValueError, TypeError):
                            continue
        
        return completed_today

    def delete_test_case(self, test_case_id):
        print("\n######################################\nAutosaving before deleting testcase\n######################################\n")
        self.save_all()
        print("\n######################################\nAutosave completed\n######################################\n")
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            for module_name, module_data in modules.items():
                module_data['test_cases'] = [tc for tc in module_data['test_cases'] if tc['id'] != test_case_id]

            # print("\n######################################\nDeleting testcase\n######################################\n")

            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)

            print("######################################\nTestcase deletion completed\n######################################\n")
            
            current_item = self.module_tree.currentItem()
            if current_item:
                self.display_test_cases(current_item.data(0, Qt.ItemDataRole.UserRole))
            
            self.update_project_stats()
            self.update_issues_tab()

    def autosave(self):
        if self.workspace and self.project_name is not None and self.project_day is not None:
            try:
                print("\n######################################\nAutosaving...\n######################################\n")
                self.save_all()
                print("\n######################################\nAutosave completed\n######################################\n")
            except Exception as e:
                print(f"Autosave error: {str(e)}")

    def search_test_cases(self, search_text):
        if not search_text:
            self.display_test_cases(self.current_module)
            return

        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)

            matching_test_cases = []
            for module_name, module_data in modules.items():
                for test_case in module_data['test_cases']:
                    if search_text.lower() in test_case['test case'].lower():
                        matching_test_cases.append((module_name, test_case))

            self.display_search_results(matching_test_cases)

    def display_search_results(self, matching_test_cases):
        self.clear_test_case_display()
        for module_name, test_case in matching_test_cases:
            test_case_box = TestCaseBox(test_case, [], self.workspace, parent=self)
            self.test_case_layout.addWidget(test_case_box)
        self.test_case_layout.addStretch()

    def initUI(self):
        self.setWindowTitle('Project Manager')
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        # Search bar to search for any testcase in the project
        # self.search_bar = QLineEdit()
        # self.search_bar.setPlaceholderText("Search test cases...")
        # self.search_bar.textChanged.connect(self.search_test_cases)
        # main_layout.addWidget(self.search_bar)

        # Top section (project info, buttons, and theme selection)
        top_frame = QFrame()
        top_frame.setFrameStyle(QFrame.Shape.Box | QFrame.Shadow.Raised)
        top_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        top_layout = QHBoxLayout(top_frame)
        top_layout.setContentsMargins(5, 5, 5, 5)
        top_layout.setSpacing(5)

        self.total_issues_label = QLabel("Total Issues: 0")
        self.unreported_issues_label = QLabel("Unreported Issues: 0")
        top_layout.addWidget(self.total_issues_label)
        top_layout.addWidget(self.unreported_issues_label)

        self.project_name_label = QLabel("")
        top_layout.addWidget(self.project_name_label)
        
        self.exportable_label = QLabel(f"Exportable: {self.exportable_count}")
        top_layout.addWidget(self.exportable_label)

        day_layout = QHBoxLayout()
        day_layout.setSpacing(2)
        self.project_day_label = QLabel("")
        day_layout.addWidget(self.project_day_label)
        self.project_day_edit = QLineEdit()
        self.project_day_edit.setFixedWidth(30)
        self.project_day_edit.editingFinished.connect(self.update_project_day)
        day_layout.addWidget(self.project_day_edit)
        top_layout.addLayout(day_layout)

        top_layout.addStretch(1)

        self.load_checklist_btn = QPushButton('')
        load_checklist_btn_icon_path = os.path.join(os.path.dirname(__file__), 'icons/checklist-add.png')
        self.load_checklist_btn.setIcon(QIcon(load_checklist_btn_icon_path))
        self.load_checklist_btn.setToolTip('Load checklist')
        self.load_checklist_btn.clicked.connect(self.load_checklist)
        top_layout.addWidget(self.load_checklist_btn)

        self.project_info_label = QLabel()
        self.select_folder_btn = QPushButton('')
        self.select_folder_btn.clicked.connect(self.selectFolder)
        self.select_folder_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.save_all_btn = QPushButton('')
        self.save_all_btn.clicked.connect(self.save_all)
        self.save_all_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.export_btn = QPushButton('')
        self.export_btn.setToolTip('Export Testcases')
        self.export_btn.setIcon(QIcon.fromTheme('document-print'))
        self.export_btn.clicked.connect(self.export_completed_cases)
        self.export_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.write_btn = QPushButton('')
        self.write_btn.setToolTip('Write Updates')
        self.write_btn.setIcon(QIcon.fromTheme('document-page-setup'))
        self.write_btn.clicked.connect(self.write_and_process)
        self.write_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        
        self.delete_mode_btn = QPushButton('')
        self.delete_mode_btn.clicked.connect(self.toggle_delete_mode)
        self.delete_mode_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        
        self.open_folder_btn = QPushButton('')
        self.open_folder_btn.clicked.connect(self.open_current_folder)
        self.open_folder_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        
        top_layout.addWidget(self.project_info_label)
        top_layout.addWidget(self.select_folder_btn)
        top_layout.addWidget(self.save_all_btn)
        top_layout.addWidget(self.export_btn)
        top_layout.addWidget(self.write_btn)
        top_layout.addWidget(self.delete_mode_btn)
        top_layout.addWidget(self.open_folder_btn)

        # Add theme selection buttons
        self.light_theme_btn = QPushButton()
        self.light_theme_btn.setIcon(QIcon.fromTheme('weather-clear'))
        self.light_theme_btn.setToolTip('Light Theme')
        self.light_theme_btn.clicked.connect(lambda: self.change_theme('light'))

        self.dark_theme_btn = QPushButton()
        self.dark_theme_btn.setIcon(QIcon.fromTheme('input-tablet'))
        self.dark_theme_btn.setToolTip('Dark Theme')
        self.dark_theme_btn.clicked.connect(lambda: self.change_theme('dark'))

        self.system_theme_btn = QPushButton()
        self.system_theme_btn.setIcon(QIcon.fromTheme('computer'))
        self.system_theme_btn.setToolTip('System Theme')
        self.system_theme_btn.clicked.connect(lambda: self.change_theme('system'))

        top_layout.addWidget(self.light_theme_btn)
        top_layout.addWidget(self.dark_theme_btn)
        top_layout.addWidget(self.system_theme_btn)

        # Splitter for resizable left and right sections
        self.splitter = QSplitter(Qt.Orientation.Horizontal)

        # Left side (module tree and issues tab)
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        
        # Create a tab widget
        self.left_tab_widget = QTabWidget()
        
        # Module tree tab
        self.module_tree = QTreeWidget()
        self.module_tree.setHeaderLabels(['Modules', 'Actions'])
        self.module_tree.setColumnWidth(0,250)
        self.module_tree.itemClicked.connect(self.on_module_clicked)
        self.add_module_btn = QPushButton('Add Module')
        self.add_module_btn.clicked.connect(self.add_module)
        module_widget = QWidget()
        module_layout = QVBoxLayout(module_widget)
        module_layout.addWidget(self.module_tree)
        module_layout.addWidget(self.add_module_btn)
        
        # Issues tab
        self.issues_table = QTableWidget()
        self.issues_table.setColumnCount(7)
        self.issues_table.setHorizontalHeaderLabels(['Module', 'Test Case', 'Asset', 'Location', 'Report Exported', 'Report Submitted', 'Details'])
        self.issues_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        
        # Add tabs to the tab widget
        self.left_tab_widget.addTab(module_widget, "Modules")
        self.left_tab_widget.addTab(self.issues_table, "Issues")
        
        left_layout.addWidget(self.left_tab_widget)

        # Right side (test case boxes)
        self.right_widget = QScrollArea()
        self.right_widget.setWidgetResizable(True)
        self.test_case_container = QWidget()
        self.test_case_layout = QVBoxLayout(self.test_case_container)
        self.right_widget.setWidget(self.test_case_container)

        self.splitter.addWidget(left_widget)
        self.splitter.addWidget(self.right_widget)
        
        self.splitter.setSizes([300, 900])
        self.splitter.setStretchFactor(0, 1)
        self.splitter.setStretchFactor(1, 3)

        main_layout.addWidget(top_frame)
        main_layout.addWidget(self.splitter)

        self.select_folder_btn.setIcon(QIcon.fromTheme('document-properties'))
        self.select_folder_btn.setToolTip('Select Workspace directory')
        self.save_all_btn.setIcon(QIcon.fromTheme('document-save'))
        self.save_all_btn.setToolTip('Save all')
        self.delete_mode_btn.setIcon(QIcon.fromTheme('edit-delete'))
        self.delete_mode_btn.setToolTip('Turn on DELETE mode!')
        self.open_folder_btn.setIcon(QIcon.fromTheme('folder'))
        self.open_folder_btn.setToolTip('Open current workspace directory')

        # Add keyboard shortcut for save all
        save_all_shortcut = QShortcut(QKeySequence("Ctrl+S"), self)
        save_all_shortcut.activated.connect(self.save_all)

        # Add keyboard shortcut for exporting completed testcases
        save_all_shortcut = QShortcut(QKeySequence("Ctrl+P"), self)
        save_all_shortcut.activated.connect(self.export_completed_cases)

        # Add keyboard shortcut for writing updates of exported testcases
        save_all_shortcut = QShortcut(QKeySequence("Ctrl+W"), self)
        save_all_shortcut.activated.connect(self.write_and_process)

        # Add keyboard shortcut for opening current workspace dir
        save_all_shortcut = QShortcut(QKeySequence("Ctrl+F"), self)
        save_all_shortcut.activated.connect(self.open_current_folder)

        # Add keyboard shortcut for opening new project workspace
        save_all_shortcut = QShortcut(QKeySequence("Ctrl+O"), self)
        save_all_shortcut.activated.connect(self.selectFolder)

        # Add keyboard shortcut for opening new project workspace
        save_all_shortcut = QShortcut(QKeySequence("Ctrl+Shift+N"), self)
        save_all_shortcut.activated.connect(self.add_module)

    def update_issues_tab(self):
        self.issues_table.setRowCount(0)
        total_issues = 0
        unreported_issues = 0

        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            for module_name, module_data in modules.items():
                for test_case in module_data['test_cases']:
                    if test_case['status'] == "Fail":
                        total_issues += 1
                        row_position = self.issues_table.rowCount()
                        self.issues_table.insertRow(row_position)
                        
                        self.issues_table.setItem(row_position, 0, QTableWidgetItem(module_name))
                        self.issues_table.setItem(row_position, 1, QTableWidgetItem(test_case['test case']))
                        self.issues_table.setItem(row_position, 2, QTableWidgetItem(test_case.get('asset', '')))
                        self.issues_table.setItem(row_position, 3, QTableWidgetItem(test_case.get('location', '')))
                        
                        report_exported = test_case.get('report_exported', False)
                        report_submitted = test_case.get('report_submitted', False)
                        
                        export_btn = QPushButton('Export report' if not report_exported else 'Re-export')
                        export_btn.clicked.connect(lambda _, tc=test_case: self.export_report(tc))
                        self.issues_table.setCellWidget(row_position, 4, export_btn)
                        
                        submit_chk = QCheckBox()
                        submit_chk.setChecked(report_submitted)
                        submit_chk.stateChanged.connect(lambda state, tc=test_case, m=module_name: self.update_report_submitted(state, tc, m))
                        self.issues_table.setCellWidget(row_position, 5, submit_chk)
                        
                        self.issues_table.setItem(row_position, 6, QTableWidgetItem(test_case.get('comment', '')))
                        
                        if not report_submitted:
                            unreported_issues += 1

        self.update_issue_counts(total_issues, unreported_issues)

    def update_issue_counts(self, total_issues, unsubmitted_reports):
        self.total_issues_label.setText(f"Total Issues: {total_issues}")
        if unsubmitted_reports > 0:
            self.unreported_issues_label.setText(f"Unsubmitted Reports: {unsubmitted_reports}")
        else:
            self.unreported_issues_label.setText("")

    def export_report(self, test_case):
        if not self.workspace:
            QMessageBox.warning(self, "Export Error", "Please select a workspace first.")
            return

        module_file = os.path.join(self.workspace, 'modules.json')
        with open(module_file, 'r') as f:
            modules = json.load(f)

        # Find the module containing the test case
        module_name = None
        for mod_name, mod_data in modules.items():
            if any(tc['id'] == test_case['id'] for tc in mod_data['test_cases']):
                module_name = mod_name
                break

        if not module_name:
            QMessageBox.warning(self, "Export Error", "Could not find the module for this test case.")
            return

        # Create the reports directory if it doesn't exist
        reports_dir = os.path.join(self.workspace, 'reports')
        os.makedirs(reports_dir, exist_ok=True)

        # Get available templates
        template_dir = os.path.join(os.path.dirname(__file__), 'report_templates')
        template_files = [f for f in os.listdir(template_dir) if f.endswith('.json')]

        if not template_files:
            QMessageBox.warning(self, "Export Error", "No report templates found.")
            return

        # Create a dialog for template selection
        dialog = QDialog(self)
        dialog.setWindowTitle("Select Report Template")
        layout = QVBoxLayout(dialog)

        template_combo = QComboBox()
        template_combo.addItems(template_files)
        layout.addWidget(QLabel("Select a template:"))
        layout.addWidget(template_combo)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)

        if dialog.exec() == QDialog.DialogCode.Accepted:
            selected_template = template_combo.currentText()
            template_file = os.path.join(template_dir, selected_template)

            with open(template_file, 'r') as f:
                template_data = json.load(f)

            # Create the report filename
            filename = f"{test_case['test case']}_in_{test_case['location']}_in_{module_name}_module_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.md"
            report_path = os.path.join(reports_dir, filename)

            # Generate the report content
            report_content = self.generate_report_content(test_case, template_data)

            # Write the report to file
            with open(report_path, 'w') as f:
                f.write(report_content)

            # Mark the test case as exported
            test_case['report_exported'] = True
            self.save_modules()
            self.update_issues_tab()

            QMessageBox.information(self, "Report Exported", f"Report for '{test_case['test case']}' has been exported to {report_path}")
        else:
            QMessageBox.information(self, "Export Cancelled", "Report export was cancelled.")

    def generate_report_content(self, test_case, template_data):
        content = f"# {template_data['Test case title']}\n\n"

        content += "## Background Information\n```\n"
        content += template_data['Background Information'] + "\n```\n\n"

        content += "## Problem Details\n```\n"
        content += f"{test_case['technique']}\n"
        content += f"{test_case['location']}\n"
        content += f"{test_case['comment']}\n```\n\n"

        content += "## Affected Asset\n```\n"
        content += f"{test_case['asset']}\n```\n\n"

        content += "## Prerequisite\n\n"
        content += "## Steps to Reproduce\n\n"

        content += "## Impact\n"
        for impact_type, impact_text in template_data['Impact'].items():
            if impact_type != 'Sample':
                content += f"### {impact_type}\n```\n{impact_text}\n```\n\n"

        content += "## Remediation\n"
        for remediation in template_data['Remediation']:
            content += f"```\n{remediation}\n```\n\n"

        content += "## Reference\n"
        for ref_name, ref_url in template_data['Reference'].items():
            content += f"```\n{ref_name}: {ref_url}\n```\n\n"

        return content

    def update_report_submitted(self, state, test_case, module_name):
        test_case['report_submitted'] = state == Qt.CheckState.Checked.value
        self.save_modules(update_test_case=test_case, module_name=module_name)
        self.update_issues_tab()

    def change_theme(self, theme):
        self.settings.setValue("theme", theme)
        self.apply_theme(theme)

    def apply_theme(self, theme):
        if theme == 'light':
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #f0f0f0;
                    color: #000000;
                }
                QTreeWidget, QListWidget {
                    background-color: #ffffff;
                    color: #000000;
                }
                QPushButton {
                    background-color: #e0e0e0;
                    color: #000000;
                }
            """)
        elif theme == 'dark':
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #2b2b2b;
                    color: #ffffff;
                }
                QTreeWidget, QListWidget {
                    background-color: #3c3f41;
                    color: #ffffff;
                }
                QPushButton {
                    background-color: #4b6eaf;
                    color: #ffffff;
                }
            """)
        else:  # system theme
            self.setStyleSheet("")

    def open_current_folder(self):
        if self.workspace:
            os.startfile(self.workspace)
        else:
            QMessageBox.warning(self, "Warning", "No workspace selected.")

    def toggle_delete_mode(self):
        self.delete_mode = not self.delete_mode
        if self.delete_mode:
            self.delete_mode_btn.setText('')
            self.delete_mode_btn.setStyleSheet('background-color: red;')
        else:
            self.delete_mode_btn.setText('')
            self.delete_mode_btn.setStyleSheet('')

    def update_project_day(self):
        try:
            new_day = int(self.project_day_edit.text())
            self.project_day = new_day
            self.saveProjectInfo()
            self.updateProjectInfo()
        except ValueError:
            QMessageBox.warning(self, "Invalid Input", "Please enter a valid number for the project day.")
            self.project_day_edit.setText(str(self.project_day))

    def export_completed_cases(self):
        if not self.workspace:
            QMessageBox.warning(self, "Export Error", "Please select a workspace first.")
            return

        today = datetime.now()
        completed_cases = []

        module_file = os.path.join(self.workspace, 'modules.json')
        try:
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)

                for module_name, module_data in modules.items():
                    for test_case in module_data['test_cases']:
                        if test_case['status'] in ["Pass", "Fail"] and not test_case.get('exported', False):
                            test_case_copy = test_case.copy()
                            test_case_copy['module'] = module_name
                            completed_cases.append(test_case_copy)

            if not completed_cases:
                QMessageBox.information(self, "Export Info", "No new completed test cases to export.")
                return

            # Create Exported folder if it doesn't exist
            export_folder = os.path.join(self.workspace, 'Exported')
            os.makedirs(export_folder, exist_ok=True)

            # Create a new folder with the specified format
            export_subfolder = f"{today.strftime('%Y-%m-%d_%H-%M-%S')}_{len(completed_cases)}"
            export_path = os.path.join(export_folder, export_subfolder)
            os.makedirs(export_path, exist_ok=True)

            # Debugging: Print total number of cases
            print("\n######################################\n")
            print("Exporting test cases")
            print(f"Total test case: {len(completed_cases)}")

            # Export test cases in sets of 5
            for i in range(0, len(completed_cases), 5):
                batch = completed_cases[i:i+5]
                
                # Debugging: Print information about each batch
                print(f"Processing batch {i//5 + 1}, size: {len(batch)}")
                
                filename = f"Project-{self.project_name}_day-{self.project_day}_update-set-{i//5+1}.txt"
                filepath = os.path.join(export_path, filename)

                # Debugging: Print the file being created
                # print(f"Creating file: {filepath}")

                with open(filepath, 'w') as f:
                    for j, case in enumerate(batch, 1):
                        f.write(f"Entry {j}:\n")
                        
                        # Write only non-empty fields
                        if case.get('test case'):
                            f.write(f"Testcase: {case['test case']}\n")
                        if case.get('asset'):
                            asset_field_name = self.get_asset_field_name()
                            f.write(f"{asset_field_name}: **{case['asset']}**\n")
                        if case.get('location'):
                            f.write(f"Location: {case['location']}\n")
                        if case.get('module'):
                            f.write(f"Module: {case['module']}\n")
                        if case.get('technique'):
                            f.write(f"Technique: {case['technique']}\n")
                        if case.get('comment'):
                            f.write(f"Comment: {case['comment']}\n")
                        if case.get('outcome'):
                            f.write(f"Outcome: {case['outcome']}\n")
                        
                        f.write("\n")                
                # Debugging: Print confirmation after writing each file
                # print(f"Finished writing file: {filepath}")

            # Debugging: Print confirmation after all processing is done
            print("Finished processing all cases")
            print("\n######################################\n")

            # Mark exported cases as exported
            for module_name, module_data in modules.items():
                for test_case in module_data['test_cases']:
                    if test_case['status'] in ["Pass", "Fail"] and not test_case.get('exported', False):
                        test_case['exported'] = True

            # Save the updated modules
            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)

            QMessageBox.information(self, "Export Successful", f"Exported {len(completed_cases)} completed test cases to Exported/{export_subfolder}")
            
            # Refresh the current module display
            current_item = self.module_tree.currentItem()
            if current_item:
                current_module = current_item.data(0, Qt.ItemDataRole.UserRole)
                self.display_test_cases(current_module)
            
            self.update_project_stats()
            self.update_issues_tab()
        except Exception as e:
            print(f"Error exporting completed cases: {str(e)}")
            QMessageBox.warning(self, "Export Error", f"Could not export completed cases: {str(e)}")

    def get_asset_field_name(self):
        asset_field_names = {
            'Web app': 'URL',
            'API': 'Endpoint',
            'Network': 'IP',
            'Source code review': 'File path',
            'Android': 'Asset'
        }
        return asset_field_names.get(self.asset_type, 'Asset')

    def save_all(self):
        print("Trying save all")
        if self.current_module:
            self.save_all_test_cases()
        self.save_modules()
        self.saveProjectInfo()
        self.update_project_stats()
        self.update_issues_tab()
        print("All changes saved manually.")
        # QMessageBox.information(self, "Save Successful", "All changes have been saved successfully.")

    def selectFolder(self):
        self.clear_test_case_display()
        try:
            folder = QFileDialog.getExistingDirectory(self, "Select Workspace Folder")
            if folder:
                self.workspace = folder
                self.getProjectInfo()  # This will prompt for project name and day
                self.load_project()
                return folder
            else:
                print("No workspace selected.")
                return None
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while selecting the workspace: {str(e)}")
            print(f"Error in selectFolder: {str(e)}")
            import traceback
            traceback.print_exc()
            return None

    def checkLogFile(self):
        log_file = os.path.join(self.workspace, 'project_log.txt')
        if os.path.exists(log_file):
            try:
                with open(log_file, 'r') as f:
                    content = f.read().strip().split(',')
                    self.project_name = content[0]
                    self.project_day = int(content[1])
                    last_date = datetime.strptime(content[2], '%Y-%m-%d').date() if len(content) > 2 else datetime.now().date()
                    self.checklist_path = content[3] if len(content) > 3 else ''
                    self.asset_type = content[4] if len(content) > 4 else 'Web app'  # Default to 'Web app' if not specified
                
                today = datetime.now().date()
                if today > last_date:
                    self.project_day += 1
                    self.saveProjectInfo()
                
                self.updateProjectInfo()
                
                if self.checklist_path and os.path.exists(self.checklist_path):
                    self.load_checklist_from_path(self.checklist_path)
                
            except (IndexError, ValueError):
                self.getProjectInfo()
        else:
            self.getProjectInfo()

    def load_checklist_from_path(self, path):
        try:
            with open(path, 'r') as f:
                self.checklist = [line.strip() for line in f if line.strip()]
            print("\n######################################\nAutomatic checklist load")
            print(f"Checklist loaded from {path}")
            print("\n######################################\n")
        except Exception as e:
            print(f"Error loading checklist from {path}: {str(e)}")
            QMessageBox.warning(self, "Checklist Load Error", f"Could not load checklist: {str(e)}")

    def getProjectInfo(self):
        project_name, ok = QInputDialog.getText(self, 'Project Name', 'Enter project name:')
        if ok:
            project_day, ok = QInputDialog.getInt(self, 'Project Day', 'Enter project day:')
            if ok:
                asset_types = ["Web app", "API", "Network", "Source code review", "Android"]
                asset_type, ok = QInputDialog.getItem(self, 'Asset Type', 'Select asset type:', asset_types, 0, False)
                if ok:
                    self.project_name = project_name
                    self.project_day = project_day
                    self.asset_type = asset_type
                    self.saveProjectInfo()
                    self.updateProjectInfo()

    def saveProjectInfo(self):
        if not self.workspace or self.project_name is None or self.project_day is None or self.asset_type is None:
            print("Project information is incomplete. Cannot save.")
            return

        log_file = os.path.join(self.workspace, 'project_log.txt')
        today = datetime.now().date()
        checklist_path = getattr(self, 'checklist_path', '')
        try:
            with open(log_file, 'w') as f:
                f.write(f"{self.project_name},{self.project_day},{today},{checklist_path},{self.asset_type}")
        except IOError as e:
            print(f"Error saving project info: {str(e)}")
            QMessageBox.warning(self, "Save Error", f"Could not save project info: {str(e)}")

    def updateProjectInfo(self):
        if self.project_name:
            self.project_name_label.setText(f"{self.project_name}")
            self.setWindowTitle(f"TCM - {self.project_name}")  # Update window title
        if self.project_day is not None:
            self.project_day_edit.setText(str(self.project_day))

    def loadModules(self):
        try:
            module_file = os.path.join(self.workspace, 'modules.json')
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)
                self.module_tree.clear()
                for module_name, module_data in modules.items():
                    self.add_module_to_tree(module_name, module_data)
            self.update_project_stats()
            self.update_issues_tab()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while loading modules: {str(e)}")
            print(f"Error in loadModules: {str(e)}")

    def add_module(self):
        try:
            module_name, ok = QInputDialog.getText(self, 'Add Module', 'Enter module name:')
            if ok and module_name:
                asset, ok = QInputDialog.getText(self, 'Add Module asset', 'Enter default asset (optional):')
                module_id = str(uuid.uuid4())  # Generate a unique ID for the new module
                self.add_module_to_tree(module_name)
                self.save_modules(new_module=module_name, module_id=module_id, module_asset=asset)
            self.update_project_stats()
            self.update_issues_tab()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while adding a module: {str(e)}")
            print(f"Error in add_module: {str(e)}")

        for i in range(self.module_tree.topLevelItemCount()):
            item = self.module_tree.topLevelItem(i)
            if item.data(0, Qt.ItemDataRole.UserRole) == module_name:
                self.module_tree.setCurrentItem(item)
                self.on_module_clicked(item, 0)
                break

    def add_module_to_tree(self, module_name, module_data=None):
        module_item = QTreeWidgetItem(self.module_tree, [module_name])
        module_item.setData(0, Qt.ItemDataRole.UserRole, module_name)
        
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0, 0, 0, 0)
        button_layout.setSpacing(2)
        
        add_btn = QPushButton()
        add_btn.setIcon(QIcon.fromTheme('list-add'))
        add_btn.setFixedSize(24, 24)
        add_btn.setToolTip("Add new testcase")
        add_btn.clicked.connect(lambda: self.add_fields_to_module(module_item))

        bulk_add_btn = QPushButton()
        bulk_add_btn_icon_path = os.path.join(os.path.dirname(__file__), 'icons/bulk-add.png')
        bulk_add_btn.setToolTip("Add new testcases in bulk")
        bulk_add_btn.setIcon(QIcon(bulk_add_btn_icon_path))

        bulk_add_btn.setFixedSize(24, 24)
        bulk_add_btn.clicked.connect(lambda: self.add_bulk_test_cases(module_item))
        
        load_checklist_btn = QPushButton()
        load_checklist_btn_icon_path = os.path.join(os.path.dirname(__file__), 'icons/checklist.png')
        load_checklist_btn.setIcon(QIcon(load_checklist_btn_icon_path))
        load_checklist_btn.setToolTip("Load testcases from checklist")
        load_checklist_btn.setFixedSize(24, 24)
        load_checklist_btn.clicked.connect(lambda: self.load_checklist_for_module(module_item))
        
        delete_btn = QPushButton()
        delete_btn.setIcon(QIcon.fromTheme('edit-delete'))
        delete_btn.setToolTip("Delete module")
        delete_btn.setFixedSize(24, 24)
        delete_btn.clicked.connect(lambda: self.delete_module(module_item))
        
        button_layout.addWidget(add_btn)
        button_layout.addWidget(bulk_add_btn)
        button_layout.addWidget(load_checklist_btn)
        button_layout.addWidget(delete_btn)

        collapse_btn = QPushButton()
        collapse_btn.setIcon(QIcon.fromTheme('go-down'))
        collapse_btn.setToolTip("Show/Hide test cases")
        collapse_btn.setFixedSize(24, 24)
        collapse_btn.clicked.connect(lambda: self.toggle_test_case_list(module_item))
        
        button_layout.addWidget(collapse_btn)

        add_btn.setIcon(QIcon.fromTheme('list-add'))
        # bulk_add_btn.setIcon(QIcon.fromTheme('edit-copy'))
        # load_checklist_btn.setIcon(QIcon.fromTheme('document-open'))
        delete_btn.setIcon(QIcon.fromTheme('edit-delete'))

        button_widget = QWidget()
        button_widget.setLayout(button_layout)
        
        self.module_tree.setItemWidget(module_item, 1, button_widget)

    def toggle_test_case_list(self, module_item):
        module_name = module_item.data(0, Qt.ItemDataRole.UserRole)
        
        if module_item.childCount() == 0:
            # Expand
            module_file = os.path.join(self.workspace, 'modules.json')
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            if module_name in modules:
                test_cases = modules[module_name]['test_cases']
                unique_test_cases = set(tc['test case'] for tc in test_cases)
                
                for test_case in unique_test_cases:
                    child = QTreeWidgetItem(module_item, [test_case])
                    child.setData(0, Qt.ItemDataRole.UserRole, test_case)  # This line is not necessary, but keeping it for consistency
            
            module_item.setExpanded(True)
        else:
            # Collapse
            module_item.takeChildren()
            module_item.setExpanded(False)
        
        # Update the collapse button icon
        button_widget = self.module_tree.itemWidget(module_item, 1)
        collapse_btn = button_widget.layout().itemAt(4).widget()
        collapse_btn.setIcon(QIcon.fromTheme('go-up' if module_item.isExpanded() else 'go-down'))

    def filter_test_cases(self, module_name, test_case_name):
        self.clear_test_case_display()
        
        # Add action buttons at the top
        action_buttons = self.setup_action_buttons()
        self.test_case_layout.addLayout(action_buttons)
        
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)

            if module_name in modules:
                test_cases = modules[module_name]['test_cases']
                filtered_test_cases = [tc for tc in test_cases if tc['test case'] == test_case_name]
                
                for test_case in filtered_test_cases:
                    test_case_box = TestCaseBox(test_case, [], self.workspace, parent=self)
                    self.test_case_layout.addWidget(test_case_box)
        
        self.test_case_layout.addStretch()

    def load_checklist_for_module(self, module_item):
        module_name = module_item.data(0, Qt.ItemDataRole.UserRole)
        
        # Get the default asset for this module
        module_file = os.path.join(self.workspace, 'modules.json')
        with open(module_file, 'r') as f:
            modules = json.load(f)
        default_asset = modules[module_name].get('asset', '')
        
        # Open file dialog to select the checklist file
        file_path, _ = QFileDialog.getOpenFileName(self, "Select Checklist File", "", "Text Files (*.txt)")
        
        if file_path:
            try:
                with open(file_path, 'r') as f:
                    checklist = [line.strip().split(':', 1) for line in f if line.strip()]
                
                new_test_cases = []
                for item in checklist:
                    test_case = item[0].strip()
                    technique = item[1].strip() if len(item) > 1 else ""
                    
                    new_test_case = {
                        'test case': test_case,
                        'technique': technique,
                        'asset': default_asset,
                        'location': '',
                        'comment': '',
                        'outcome': '',
                        'created_at': datetime.now().isoformat(),
                        'completed_at': None,
                        'status': "Not Started",
                        'id': str(uuid.uuid4()),
                        'exported': False,
                        'high_priority': False  # Default to False for checklist items
                    }
                    new_test_cases.append(new_test_case)
                
                if new_test_cases:
                    self.save_modules(new_data=new_test_cases, current_module_name=module_name)
                    self.display_test_cases(module_name)
                    self.update_project_stats()
                    self.update_issues_tab()
                    QMessageBox.information(self, "Checklist Loaded", f"Added {len(new_test_cases)} new test cases from the checklist.")
                else:
                    QMessageBox.warning(self, "No Test Cases Added", "The selected file didn't contain any valid test cases.")
            
            except Exception as e:
                QMessageBox.critical(self, "Error", f"An error occurred while loading the checklist: {str(e)}")

    def add_bulk_test_cases(self, module_item):
        module_name = module_item.data(0, Qt.ItemDataRole.UserRole)
        
        # Get the default asset for this module
        module_file = os.path.join(self.workspace, 'modules.json')
        with open(module_file, 'r') as f:
            modules = json.load(f)
        default_asset = modules[module_name].get('asset', '')
        
        dialog = BulkTestCaseDialog(self, self.checklist)
        dialog.asset_edit.setText(default_asset)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            data = dialog.get_data()
            new_test_cases = []
            
            for location in data['locations']:
                if location.strip():  # Ignore empty lines
                    new_test_case = {
                        'test case': data['test_case'],
                        'technique': data['technique'],
                        'asset': data['asset'] or default_asset,
                        'location': location.strip(),
                        'comment': data['comment'],
                        'outcome': data['outcome'],
                        'created_at': datetime.now().isoformat(),
                        'completed_at': None,
                        'status': "Not Started",
                        'id': str(uuid.uuid4()),
                        'exported': False,
                        'high_priority': data['high_priority']
                    }
                    new_test_cases.append(new_test_case)
            
            if new_test_cases:
                self.save_modules(new_data=new_test_cases, current_module_name=module_name)
                self.display_test_cases(module_name)
                self.update_project_stats()
                self.update_issues_tab()
                QMessageBox.information(self, "Bulk Add Successful", f"Added {len(new_test_cases)} new test cases.")
            else:
                QMessageBox.warning(self, "No Test Cases Added", "No valid locations were provided.")

    def delete_module(self, module_item):
        module_name = module_item.data(0, Qt.ItemDataRole.UserRole)
        reply = QMessageBox.warning(
            self,
            "Delete Module",
            f"<font color='red'>Warning: This will delete all test cases in the module '{module_name}'.</font><br><br>Are you sure you want to proceed?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            module_file = os.path.join(self.workspace, 'modules.json')
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)
                
                if module_name in modules:
                    del modules[module_name]
                    
                    with open(module_file, 'w') as f:
                        json.dump(modules, f, indent=2)
                    
                    # Remove the module from the tree
                    root = self.module_tree.invisibleRootItem()
                    root.removeChild(module_item)
                    
                    # Clear the test case display
                    self.clear_test_case_display()
                    
                    self.update_project_stats()
                    self.update_issues_tab()
                    QMessageBox.information(self, "Module Deleted", f"Module '{module_name}' has been deleted.")
                else:
                    QMessageBox.warning(self, "Error", f"Module '{module_name}' not found.")
            else:
                QMessageBox.warning(self, "Error", "Module file not found.")

    def clear_test_case_display(self):
        while self.test_case_layout.count():
            item = self.test_case_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

    def add_fields_to_module(self, module_item):
        module_name = module_item.data(0, Qt.ItemDataRole.UserRole)
        
        dialog = QDialog(self)
        dialog.setWindowTitle('Add Test Case')
        layout = QVBoxLayout(dialog)
        
        combo = QComboBox()
        combo.addItems([item.split(':', 1)[0] for item in self.checklist])
        combo.setEditable(True)
        layout.addWidget(QLabel('Select or enter test case:'))
        layout.addWidget(combo)
        
        technique_edit = QLineEdit()
        layout.addWidget(QLabel('Technique:'))
        layout.addWidget(technique_edit)
        
        asset_edit = QLineEdit()
        layout.addWidget(QLabel('asset:'))
        layout.addWidget(asset_edit)
        
        priority_checkbox = QCheckBox("High Priority")
        layout.addWidget(priority_checkbox)

        # Get the default asset for this module
        module_file = os.path.join(self.workspace, 'modules.json')
        with open(module_file, 'r') as f:
            modules = json.load(f)
        default_asset = modules[module_name].get('asset', '')
        asset_edit.setText(default_asset)
        
        def update_technique(index):
            if 0 <= index < len(self.checklist):
                parts = self.checklist[index].split(':', 1)
                if len(parts) > 1:
                    technique_edit.setText(parts[1].strip())
                else:
                    technique_edit.clear()
            else:
                technique_edit.clear()
        
        combo.currentIndexChanged.connect(update_technique)
        
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            test_case = combo.currentText()
            technique = technique_edit.text()
            asset = asset_edit.text() or default_asset
            
            if test_case:
                new_data = {
                    'test case': test_case,
                    'technique': technique,
                    'asset': asset,
                    'location': '',
                    'comment': '',
                    'outcome': '',
                    'created_at': datetime.now().isoformat(),
                    'completed_at': None,
                    'status': "Not Started",
                    'id': str(uuid.uuid4()),
                    'exported': False,
                    'high_priority': priority_checkbox.isChecked()
                }
                
                self.save_modules(new_data=new_data, current_module_name=module_name)
                self.display_test_cases(module_name)
        
        self.update_project_stats()
        self.update_issues_tab()

    def save_modules(self, new_data=None, current_module_name=None, new_module=None, module_id=None, module_asset=None, update_test_case=None, module_name=None):
        if not self.workspace:
            QMessageBox.warning(self, "Warning", "No workspace selected. Cannot save modules.")
            return

        try:
            module_file = os.path.join(self.workspace, 'modules.json')
            
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)
            else:
                modules = {}

            if new_module:
                if new_module not in modules:
                    modules[new_module] = {'id': module_id, 'asset': module_asset, 'test_cases': []}

            if new_data and current_module_name:
                if current_module_name not in modules:
                    modules[current_module_name] = {'id': str(uuid.uuid4()), 'asset': '', 'test_cases': []}
                if isinstance(new_data, list):
                    for item in new_data:
                        item['report_exported'] = False
                        item['report_submitted'] = False
                    modules[current_module_name]['test_cases'] = new_data + modules[current_module_name]['test_cases']
                else:
                    new_data['report_exported'] = False
                    new_data['report_submitted'] = False
                    modules[current_module_name]['test_cases'].insert(0, new_data)

            if update_test_case and module_name:
                for i, test_case in enumerate(modules[module_name]['test_cases']):
                    if test_case['id'] == update_test_case['id']:
                        modules[module_name]['test_cases'][i] = update_test_case
                        break

            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)

            self.update_project_stats()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while saving modules: {str(e)}")
            print(f"Error in save_modules: {str(e)}")

    def on_module_clicked(self, item, column):
        if item.parent() is None:
            # Module clicked
            module_name = item.data(0, Qt.ItemDataRole.UserRole)
            self.current_module_name = module_name
            self.current_module = module_name
            self.current_view = 'module'
            self.display_test_cases(module_name)
        else:
            # Test case clicked
            module_name = item.parent().data(0, Qt.ItemDataRole.UserRole)
            test_case_name = item.text(0)
            self.current_module_name = module_name
            self.current_module = test_case_name
            self.current_view = 'filtered'
            self.filter_test_cases(module_name, test_case_name)

    def save_all_test_cases(self):
        for i in range(self.test_case_layout.count()):
            item = self.test_case_layout.itemAt(i)
            if item.widget():
                test_case_box = item.widget()
                test_case_box.save_changes()

    def display_test_cases(self, module_name):
        # Clear existing layout
        while self.test_case_layout.count():
            item = self.test_case_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Add action buttons at the top
        action_buttons = self.setup_action_buttons()
        self.test_case_layout.addLayout(action_buttons)

        module_file = os.path.join(self.workspace, 'modules.json')
        
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)

            if module_name in modules:
                test_cases = modules[module_name]['test_cases']
                for test_case in test_cases:
                    if isinstance(test_case.get('test case'), list):
                        test_case['test case'] = test_case['test case'][0] if test_case['test case'] else ''
                    test_case_box = TestCaseBox(test_case, [], self.workspace, parent=self)
                    self.test_case_layout.addWidget(test_case_box)
            
            # Add stretch to push boxes to the top
            self.test_case_layout.addStretch()

        # Turn off scrolling for test case titles
        # self.right_widget.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOn)
        # self.right_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)

    def refresh_test_cases(self):
        if self.current_view == 'module':
            self.refresh_module_test_cases()
        else:
            self.refresh_filtered_test_cases()

    def save_test_case(self, updated_test_case):
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            if self.current_module_name in modules:
                # Find and update the specific test case
                for i, test_case in enumerate(modules[self.current_module_name]['test_cases']):
                    if test_case['id'] == updated_test_case['id']:
                        modules[self.current_module_name]['test_cases'][i] = updated_test_case
                        break
                
                with open(module_file, 'w') as f:
                    json.dump(modules, f, indent=2)

                print("\n######################################\nTest case update\n")
                print(f"Test case '{updated_test_case['test case']}' updated successfully.")
                print("\n######################################\n")
                self.update_project_stats()
                self.update_issues_tab()
            else:
                print(f"Error: Module '{self.current_module_name}' not found in modules.")

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = ProjectManager()
    sys.exit(app.exec())
