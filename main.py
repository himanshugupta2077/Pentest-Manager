import sys
import os
import json
from datetime import datetime
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
                             QPushButton, QFileDialog, QInputDialog, QLabel, QListWidget,
                             QSplitter, QFrame, QSizePolicy, QTreeWidget, QTreeWidgetItem,
                             QScrollArea, QLineEdit, QFormLayout, QComboBox, QButtonGroup, QCompleter, QMessageBox)
from PyQt6.QtCore import Qt, QTimer
from PyQt6.QtGui import QIcon
from PyQt6.QtCore import QSettings
import re
import anthropic
from PyQt6.QtWidgets import QComboBox, QMessageBox
import uuid

class TestCaseBox(QFrame):
    def __init__(self, test_case_data, test_cases, workspace, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.test_case_data = test_case_data
        self.workspace = workspace
        self.setFrameStyle(QFrame.Shape.Box | QFrame.Shadow.Raised)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        
        self.setStyleSheet("""
            TestCaseBox {
                background-color: #555555;
                border: 1px #555555;
                border-radius: 5px;
            }
        """)
        
        main_layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        main_layout.addLayout(form_layout)
        
        self.fields = {}
        
        for field, value in test_case_data.items():
            if field not in ['created_at', 'completed_at', 'status', 'id']:
                if field == 'test case':
                    combo = QComboBox()
                    combo.setEditable(True)
                    combo.addItems(test_cases)
                    combo.setCurrentText(value)
                    combo.setInsertPolicy(QComboBox.InsertPolicy.NoInsert)
                    combo.completer().setCompletionMode(QCompleter.CompletionMode.PopupCompletion)
                    form_layout.addRow(combo)
                    self.fields[field] = combo
                else:
                    line_edit = QLineEdit(value)
                    line_edit.setPlaceholderText(field.capitalize())
                    form_layout.addRow(line_edit)
                    self.fields[field] = line_edit
        
        bottom_layout = QHBoxLayout()
        bottom_layout.addStretch(1)
        
        copy_button = QPushButton("Make a copy")
        copy_button.clicked.connect(self.copy_test_case)
        copy_button.setFixedWidth(80)
        bottom_layout.addWidget(copy_button)
        
        self.status_button_group = QButtonGroup(self)
        self.not_done_button = QPushButton("Not done")
        self.completed_button = QPushButton("Completed")
        self.not_done_button.setCheckable(True)
        self.completed_button.setCheckable(True)
        self.not_done_button.setFixedWidth(80)
        self.completed_button.setFixedWidth(80)
        
        self.status_button_group.addButton(self.not_done_button)
        self.status_button_group.addButton(self.completed_button)
        
        bottom_layout.addWidget(self.not_done_button)
        bottom_layout.addWidget(self.completed_button)
        
        if test_case_data.get('status', "Not done") == "Not done":
            self.not_done_button.setChecked(True)
        else:
            self.completed_button.setChecked(True)
        
        self.status_button_group.buttonClicked.connect(self.on_status_changed)
        
        save_button = QPushButton("Save")
        save_button.clicked.connect(self.save_changes)
        save_button.setFixedWidth(60)
        bottom_layout.addWidget(save_button)
        
        self.delete_button = QPushButton("Delete")
        self.delete_button.clicked.connect(self.delete_test_case)
        self.delete_button.setFixedWidth(60)
        bottom_layout.addWidget(self.delete_button)

        main_layout.addLayout(bottom_layout)

    def copy_test_case(self):
        new_test_case = self.test_case_data.copy()
        new_test_case['test case'] = f"{new_test_case['test case']} (Copy)"
        new_test_case['created_at'] = datetime.now().isoformat()
        new_test_case['completed_at'] = None
        new_test_case['status'] = "Not done"
        new_test_case['id'] = str(uuid.uuid4())  # Generate a new unique ID for the copy
        
        if self.parent:
            self.parent.add_copied_test_case(new_test_case)

    def delete_test_case(self):
        if self.parent and self.parent.delete_mode:
            self.parent.delete_test_case(self.test_case_data['id'])
        else:
            reply = QMessageBox.question(self, 'Delete Test Case',
                                         f"Are you sure you want to delete the test case '{self.test_case_data['test case']}'?",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                         QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.Yes:
                self.parent.delete_test_case(self.test_case_data['id'])

    def on_status_changed(self, button):
        new_status = "Completed" if button == self.completed_button else "Not done"
        if new_status == "Completed" and self.test_case_data['status'] != "Completed":
            self.test_case_data['completed_at'] = datetime.now().isoformat()
        elif new_status == "Not done":
            self.test_case_data['completed_at'] = None
        self.test_case_data['status'] = new_status
        self.save_changes()  # Save changes immediately when status is changed

    def save_changes(self):
        for field, widget in self.fields.items():
            if isinstance(widget, QComboBox):
                self.test_case_data[field] = widget.currentText()
            else:
                self.test_case_data[field] = widget.text()
        
        self.test_case_data['status'] = "Completed" if self.completed_button.isChecked() else "Not done"
        
        if self.parent:
            self.parent.save_test_case(self.test_case_data)
            self.parent.update_project_stats()

class ProjectManager(QMainWindow):
    def __init__(self):
        super().__init__()
        self.workspace = None
        self.project_name = None
        self.project_day = None
        self.checklist_I = self.load_checklist('checklist_I.txt')
        self.checklist_II = self.load_checklist('checklist_II.txt')
        self.delete_mode = False
        self.initUI()
        
        # Set up autosave timer
        self.autosave_timer = QTimer(self)
        self.autosave_timer.timeout.connect(self.autosave)
        self.autosave_timer.start(1000)  # 1000 ms = 1 second

        # Maximize the window
        self.showMaximized()

        # Auto-trigger workspace selection after a short delay
        QTimer.singleShot(100, self.autoSelectWorkspace)

    def load_checklist(self, filename):
        checklist_path = os.path.join(os.path.dirname(__file__), filename)
        if os.path.exists(checklist_path):
            with open(checklist_path, 'r') as f:
                return [line.strip() for line in f if line.strip()]
        return []

    def autoSelectWorkspace(self):
        # Check if there's a last used workspace
        settings = QSettings("YourCompany", "ProjectManager")
        last_workspace = settings.value("last_workspace", "")

        if last_workspace and os.path.exists(last_workspace):
            self.workspace = last_workspace
            try:
                self.checkLogFile()
                self.loadModules()
                self.update_project_stats()
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Error loading last workspace: {str(e)}")
                self.selectFolder()
        else:
            self.selectFolder()

    def anonymize_URLs(self, content):
        URL_pattern = re.compile(r'\*\*(.*?)\*\*')
        placeholders = {}
        
        def replace_URL(match):
            URL = match.group(1)
            placeholder = f'URL_PLACEHOLDER_{len(placeholders)}'
            placeholders[placeholder] = URL
            return placeholder
        
        anonymized_content = URL_pattern.sub(replace_URL, content)
        return anonymized_content, placeholders

    def process_with_anthropic(self, content, prompt):
        client = anthropic.Anthropic(api_key=os.environ.get('ANTHROPIC_API_KEY'))
        full_prompt = f"{prompt}\n\n{content}"
        message = client.messages.create(
            model="claude-3-5-sonnet-20240620",
            max_tokens=1000,
            temperature=0,
            messages=[
                {
                    "role": "user",
                    "content": full_prompt
                }
            ]
        )
        processed_content = message.content[0].text
        return processed_content

    def reinsert_URLs(self, content, placeholders):
        for placeholder, URL in placeholders.items():
            content = content.replace(placeholder, f"{URL}")
        content = re.sub(r'\n\n+', '\n', content)
        return content

    def write_and_process(self):
        if not self.workspace:
            QMessageBox.warning(self, "Error", "Please select a workspace first.")
            return

        try:
            # Get today's exported file
            today = datetime.now().date()
            export_folder = os.path.join(self.workspace, 'Exported')
            today_files = [f for f in os.listdir(export_folder) if f.startswith(f"{self.project_name}-{self.project_day}-{today.strftime('%Y-%m-%d')}")]

            if not today_files:
                QMessageBox.warning(self, "Error", "No exported file found for today.")
                return

            latest_file = max(today_files)
            file_path = os.path.join(export_folder, latest_file)

            # Read the content
            with open(file_path, 'r') as f:
                content = f.read()

            # Anonymize URLs
            anonymized_content, placeholders = self.anonymize_URLs(content)

            # Get prompts from the prompts folder
            prompts_folder = os.path.join(os.path.dirname(__file__), 'prompts')
            prompts = [f for f in os.listdir(prompts_folder) if f.endswith('.txt')]

            if not prompts:
                QMessageBox.warning(self, "Error", "No prompts found in the prompts folder.")
                return

            # Let user select a prompt
            prompt, ok = QInputDialog.getItem(self, "Select Prompt", "Choose a prompt:", prompts, 0, False)
            if not ok:
                return

            # Read the selected prompt
            with open(os.path.join(prompts_folder, prompt), 'r') as f:
                prompt_content = f.read()

            # Process with Anthropic
            processed_content = self.process_with_anthropic(anonymized_content, prompt_content)

            # Reinsert URLs
            final_content = self.reinsert_URLs(processed_content, placeholders)

            # Save the output
            updates_folder = os.path.join(self.workspace, 'Updates')
            os.makedirs(updates_folder, exist_ok=True)
            output_file = f"update_{today.strftime('%Y-%m-%d')}_{datetime.now().strftime('%H-%M-%S')}.txt"
            output_path = os.path.join(updates_folder, output_file)

            with open(output_path, 'w') as f:
                f.write(final_content)

            QMessageBox.information(self, "Success", f"Processed content saved to {output_path}")

        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred during processing: {str(e)}")
            print(f"Error in write_and_process: {str(e)}")

    def add_copied_test_case(self, new_test_case):
        current_item = self.module_tree.currentItem()
        if current_item:
            module_name = current_item.data(0, Qt.ItemDataRole.UserRole)
            self.save_modules(new_data=new_test_case, current_module_name=module_name)
            self.display_test_cases(module_name)
            self.update_project_stats()

    def update_project_stats(self):
        if not self.workspace:
            self.project_info_label.setText("No project selected")
            return

        total_cases = 0
        total_completed = 0
        module_file = os.path.join(self.workspace, 'modules.json')
        try:
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)
                
                for module_name, module_data in modules.items():
                    test_cases = module_data['test_cases']
                    cases_count = len(test_cases)
                    completed_count = sum(1 for case in test_cases if case['status'] == 'Completed')
                    total_cases += cases_count
                    total_completed += completed_count
                    
                    if cases_count > 0:
                        completion_percentage = round((completed_count / cases_count) * 100, 1)
                    else:
                        completion_percentage = 0
                    
                    module_item = self.find_module_item(module_name)
                    if module_item:
                        module_item.setText(0, f"{module_name} ({completion_percentage:.1f}%)")
                        module_item.setData(0, Qt.ItemDataRole.UserRole, module_name)
            
            if total_cases > 0:
                project_completion = round((total_completed / total_cases) * 100, 1)
            else:
                project_completion = 0
            
            self.update_header_info(total_cases, total_completed, project_completion)
            self.refresh_module_tree()
        except Exception as e:
            print(f"Error updating project stats: {str(e)}")
            self.project_info_label.setText("Error updating project stats")

    def refresh_module_tree(self):
        for i in range(self.module_tree.topLevelItemCount()):
            item = self.module_tree.topLevelItem(i)
            module_name = item.data(0, Qt.ItemDataRole.UserRole)
            self.update_module_percentage(item, module_name)

    def update_module_percentage(self, item, module_name):
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            if module_name in modules:
                test_cases = modules[module_name]['test_cases']
                cases_count = len(test_cases)
                completed_count = sum(1 for case in test_cases if case['status'] == 'Completed')
                
                if cases_count > 0:
                    completion_percentage = round((completed_count / cases_count) * 100, 1)
                else:
                    completion_percentage = 0
                
                item.setText(0, f"{module_name} ({completion_percentage:.1f}%)")


    def find_module_item(self, module_name):
        for i in range(self.module_tree.topLevelItemCount()):
            item = self.module_tree.topLevelItem(i)
            if item.data(0, Qt.ItemDataRole.UserRole) == module_name:
                return item
        return None

    def update_header_info(self, total_cases, total_completed, project_completion):
        today = datetime.now().date()
        completed_today = self.get_completed_today()
        
        header_text = (f"{today.strftime('%Y-%m-%d')} | "
                       f"{project_completion:.1f}% | "
                       f"Completed today: {completed_today}")
        
        self.project_info_label.setText(header_text)

    def get_completed_today(self):
        today = datetime.now().date()
        completed_today = 0
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            for module_name, module_data in modules.items():
                test_cases = module_data['test_cases']
                for case in test_cases:
                    if case['status'] == 'Completed':
                        completed_date = datetime.fromisoformat(case['completed_at']).date()
                        if completed_date == today:
                            completed_today += 1
        
        return completed_today

    def delete_test_case(self, test_case_id):
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            for module_name, module_data in modules.items():
                module_data['test_cases'] = [tc for tc in module_data['test_cases'] if tc['id'] != test_case_id]
            
            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)
            
            current_item = self.module_tree.currentItem()
            if current_item:
                self.display_test_cases(current_item.data(0, Qt.ItemDataRole.UserRole))
            
            self.update_project_stats()

    def autosave(self):
        if self.workspace and self.project_name is not None and self.project_day is not None:
            try:
                self.save_modules()
                self.saveProjectInfo()
            except Exception as e:
                print(f"Autosave error: {str(e)}")

    def initUI(self):
        self.setWindowTitle('Project Manager')
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        # Top section (project info and buttons)
        top_frame = QFrame()
        top_frame.setFrameStyle(QFrame.Shape.Box | QFrame.Shadow.Raised)
        top_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        top_layout = QHBoxLayout(top_frame)
        top_layout.setContentsMargins(5, 5, 5, 5)
        top_layout.setSpacing(5)
        
        self.project_name_label = QLabel("")
        top_layout.addWidget(self.project_name_label)
        
        day_layout = QHBoxLayout()
        day_layout.setSpacing(2)
        self.project_day_label = QLabel("")
        day_layout.addWidget(self.project_day_label)
        self.project_day_edit = QLineEdit()
        self.project_day_edit.setFixedWidth(30)
        self.project_day_edit.editingFinished.connect(self.update_project_day)
        day_layout.addWidget(self.project_day_edit)
        top_layout.addLayout(day_layout)
        
        top_layout.addStretch(1)
        
        self.project_info_label = QLabel()
        self.select_folder_btn = QPushButton('Select WS')
        self.select_folder_btn.clicked.connect(self.selectFolder)
        self.select_folder_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.save_all_btn = QPushButton('Save All')
        self.save_all_btn.clicked.connect(self.save_all)
        self.save_all_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.export_btn = QPushButton('Export')
        self.export_btn.clicked.connect(self.export_completed_cases)
        self.export_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.write_btn = QPushButton('Write')
        self.write_btn.clicked.connect(self.write_and_process)
        self.write_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        
        self.delete_mode_btn = QPushButton('Delete Mode: OFF')
        self.delete_mode_btn.clicked.connect(self.toggle_delete_mode)
        self.delete_mode_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        
        self.open_folder_btn = QPushButton('Open Folder')
        self.open_folder_btn.clicked.connect(self.open_current_folder)
        self.open_folder_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        
        top_layout.addWidget(self.project_info_label)
        top_layout.addWidget(self.select_folder_btn)
        top_layout.addWidget(self.save_all_btn)
        top_layout.addWidget(self.export_btn)
        top_layout.addWidget(self.write_btn)
        top_layout.addWidget(self.delete_mode_btn)
        top_layout.addWidget(self.open_folder_btn)

        # Splitter for resizable left and right sections
        self.splitter = QSplitter(Qt.Orientation.Horizontal)

        # Left side (module tree)
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        self.module_tree = QTreeWidget()
        self.module_tree.setHeaderLabels(['Modules', ''])
        self.module_tree.setColumnWidth(0, 350)  # Increased width for modules
        # self.module_tree.setColumnWidth(1, 500)   # Decreased width for add button
        self.module_tree.itemClicked.connect(self.on_module_clicked)
        self.add_module_btn = QPushButton('Add Module')
        self.add_module_btn.clicked.connect(self.add_module)
        left_layout.addWidget(self.module_tree)
        left_layout.addWidget(self.add_module_btn)

        # Right side (test case boxes)
        self.right_widget = QScrollArea()
        self.right_widget.setWidgetResizable(True)
        self.test_case_container = QWidget()
        self.test_case_layout = QVBoxLayout(self.test_case_container)
        self.right_widget.setWidget(self.test_case_container)

        self.splitter.addWidget(left_widget)
        self.splitter.addWidget(self.right_widget)
        
        self.splitter.setSizes([300, 900])
        self.splitter.setStretchFactor(0, 1)
        self.splitter.setStretchFactor(1, 3)

        main_layout.addWidget(top_frame)
        main_layout.addWidget(self.splitter)

    def open_current_folder(self):
        if self.workspace:
            os.startfile(self.workspace)
        else:
            QMessageBox.warning(self, "Warning", "No workspace selected.")

    def toggle_delete_mode(self):
        self.delete_mode = not self.delete_mode
        if self.delete_mode:
            self.delete_mode_btn.setText('Delete Mode: ON')
            self.delete_mode_btn.setStyleSheet('background-color: red;')
        else:
            self.delete_mode_btn.setText('Delete Mode: OFF')
            self.delete_mode_btn.setStyleSheet('')

    def update_project_day(self):
        try:
            new_day = int(self.project_day_edit.text())
            self.project_day = new_day
            self.saveProjectInfo()
            self.updateProjectInfo()
        except ValueError:
            QMessageBox.warning(self, "Invalid Input", "Please enter a valid number for the project day.")
            self.project_day_edit.setText(str(self.project_day))

    def export_completed_cases(self):
        if not self.workspace:
            QMessageBox.warning(self, "Export Error", "Please select a workspace first.")
            return

        today = datetime.now().date()
        completed_cases = []

        module_file = os.path.join(self.workspace, 'modules.json')
        try:
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)

                for module_name, module_data in modules.items():
                    for test_case in module_data['test_cases']:
                        if test_case['status'] == 'Completed':
                            completed_at = datetime.fromisoformat(test_case['completed_at']).date()
                            if completed_at == today:
                                test_case['module'] = module_name
                                completed_cases.append(test_case)

            if not completed_cases:
                QMessageBox.information(self, "Export Info", "No test cases completed today.")
                return

            # Create Exported folder if it doesn't exist
            export_folder = os.path.join(self.workspace, 'Exported')
            os.makedirs(export_folder, exist_ok=True)

            current_time = datetime.now().strftime("%H-%M-%S")
            filename = f"{self.project_name}-{self.project_day}-{today.strftime('%Y-%m-%d')}-{current_time}-{len(completed_cases)}.txt"
            filepath = os.path.join(export_folder, filename)

            with open(filepath, 'w') as f:
                for i, case in enumerate(completed_cases, 1):
                    f.write(f"Entry {i}:\n")
                    f.write(f"Testcase: {case['test case']}\n")
                    f.write(f"URL: **{case['URL']}*\n")
                    f.write(f"Location: {case['location']}\n")
                    f.write(f"Module: {case['module']}\n")
                    f.write(f"Technique: {case['technique']}\n")
                    f.write(f"Comment: {case['comment']}\n")
                    f.write(f"Outcome: {case['outcome']}\n")
                    f.write("\n")

            QMessageBox.information(self, "Export Successful", f"Exported {len(completed_cases)} completed test cases to Exported/{filename}")
        except Exception as e:
            print(f"Error exporting completed cases: {str(e)}")
            QMessageBox.warning(self, "Export Error", f"Could not export completed cases: {str(e)}")

    def load_test_cases(self):
        checklist_path = os.path.join(os.path.dirname(__file__), 'checklist_I.txt')
        if os.path.exists(checklist_path):
            with open(checklist_path, 'r') as f:
                return [line.strip() for line in f if line.strip()]
        return []

    def save_all(self):
        self.save_modules()
        self.saveProjectInfo()
        print("All changes saved manually.")

    def selectFolder(self):
        try:
            self.workspace = QFileDialog.getExistingDirectory(self, "Select Workspace Folder")
            if self.workspace:
                # Save the selected workspace for future use
                settings = QSettings("YourCompany", "ProjectManager")
                settings.setValue("last_workspace", self.workspace)

                self.checkLogFile()
                self.loadModules()
                self.update_project_stats()
            else:
                print("No workspace selected.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while selecting the workspace: {str(e)}")
            print(f"Error in selectFolder: {str(e)}")

    def checkLogFile(self):
        log_file = os.path.join(self.workspace, 'project_log.txt')
        if os.path.exists(log_file):
            try:
                with open(log_file, 'r') as f:
                    content = f.read().strip().split(',')
                    self.project_name = content[0]
                    self.project_day = int(content[1])
                    last_date = datetime.strptime(content[2], '%Y-%m-%d').date() if len(content) > 2 else datetime.now().date()
                
                today = datetime.now().date()
                if today > last_date:
                    self.project_day += 1
                    self.saveProjectInfo()
                
                self.updateProjectInfo()
            except (IndexError, ValueError):
                self.getProjectInfo()
        else:
            self.getProjectInfo()

    def getProjectInfo(self):
        project_name, ok = QInputDialog.getText(self, 'Project Name', 'Enter project name:')
        if ok:
            project_day, ok = QInputDialog.getInt(self, 'Project Day', 'Enter project day:')
            if ok:
                self.project_name = project_name
                self.project_day = project_day
                self.saveProjectInfo()
                self.updateProjectInfo()
                
                # Create default "Target application" module with test cases from checklist_I
                self.add_module_to_tree("Target application")
                self.create_default_test_cases("Target application", self.checklist_I)

    def create_default_test_cases(self, module_name, checklist):
        new_test_cases = []
        for test_case_name in checklist:
            new_test_case = {
                'test case': test_case_name,
                'url': '',
                'location': '',
                'technique': '',
                'comment': '',
                'outcome': '',
                'created_at': datetime.now().isoformat(),
                'completed_at': None,
                'status': "Not done",
                'id': str(uuid.uuid4())
            }
            new_test_cases.append(new_test_case)
        
        self.save_modules(new_data=new_test_cases, current_module_name=module_name)
        self.display_test_cases(module_name)
        self.update_project_stats()

    def saveProjectInfo(self):
        if not self.workspace or self.project_name is None or self.project_day is None:
            print("Project information is incomplete. Cannot save.")
            return

        log_file = os.path.join(self.workspace, 'project_log.txt')
        today = datetime.now().date()
        try:
            with open(log_file, 'w') as f:
                f.write(f"{self.project_name},{self.project_day},{today}")
        except IOError as e:
            print(f"Error saving project info: {str(e)}")
            QMessageBox.warning(self, "Save Error", f"Could not save project info: {str(e)}")

    def updateProjectInfo(self):
        if self.project_name:
            self.project_name_label.setText(f"{self.project_name}")
        if self.project_day is not None:
            self.project_day_edit.setText(str(self.project_day))

    def loadModules(self):
        try:
            module_file = os.path.join(self.workspace, 'modules.json')
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)
                self.module_tree.clear()
                for module_name, module_data in modules.items():
                    self.add_module_to_tree(module_name, module_data)
            self.update_project_stats()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while loading modules: {str(e)}")
            print(f"Error in loadModules: {str(e)}")

    def add_module(self):
        try:
            module_name, ok = QInputDialog.getText(self, 'Add Module', 'Enter module name:')
            if ok and module_name:
                module_id = str(uuid.uuid4())  # Generate a unique ID for the new module
                self.add_module_to_tree(module_name)
                self.save_modules(new_module=module_name, module_id=module_id)
            self.update_project_stats()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while adding a module: {str(e)}")
            print(f"Error in add_module: {str(e)}")

    def add_module_to_tree(self, module_name, module_data=None):
        module_item = QTreeWidgetItem(self.module_tree, [module_name])
        module_item.setData(0, Qt.ItemDataRole.UserRole, module_name)
        add_btn = QPushButton()
        add_btn.setIcon(QIcon.fromTheme('list-add'))
        add_btn.setFixedSize(24, 24)
        add_btn.clicked.connect(lambda: self.add_fields_to_module(module_item))
        self.module_tree.setItemWidget(module_item, 1, add_btn)

    def add_fields_to_module(self, module_item):
        module_name = module_item.data(0, Qt.ItemDataRole.UserRole)
        
        # Use checklist_I for "Target application", checklist_II for others
        checklist = self.checklist_I if module_name == "Target application" else self.checklist_II
        
        # Only ask for the test case name
        test_case, ok = QInputDialog.getItem(self, 'Add Test Case', 'Select or enter test case:', checklist, 0, True)
        
        if ok and test_case:
            new_data = {
                'test case': test_case, 
                'URL': '',
                'location': '',
                'technique': '',
                'comment': '',
                'outcome': ''
            }
            
            # Add metadata
            new_data['created_at'] = datetime.now().isoformat()
            new_data['completed_at'] = None
            new_data['status'] = "Not done"
            new_data['id'] = str(uuid.uuid4())  # Generate a unique ID for the new test case
            
            self.save_modules(new_data=new_data, current_module_name=module_name)
            self.display_test_cases(module_name)
        self.update_project_stats()

    def save_modules(self, new_data=None, current_module_name=None, new_module=None, module_id=None):
        if not self.workspace:
            QMessageBox.warning(self, "Warning", "No workspace selected. Cannot save modules.")
            return

        try:
            module_file = os.path.join(self.workspace, 'modules.json')
            
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)
            else:
                modules = {}

            if new_module:
                if new_module not in modules:
                    modules[new_module] = {'id': module_id, 'test_cases': []}

            if new_data and current_module_name:
                if current_module_name not in modules:
                    modules[current_module_name] = {'id': str(uuid.uuid4()), 'test_cases': []}
                if isinstance(new_data, list):
                    modules[current_module_name]['test_cases'].extend(new_data)
                else:
                    modules[current_module_name]['test_cases'].append(new_data)

            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)

            self.update_project_stats()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while saving modules: {str(e)}")
            print(f"Error in save_modules: {str(e)}")

    def on_module_clicked(self, item, column):
        module_name = item.data(0, Qt.ItemDataRole.UserRole)
        self.display_test_cases(module_name)

    def display_test_cases(self, module_name):
        while self.test_case_layout.count():
            item = self.test_case_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        module_file = os.path.join(self.workspace, 'modules.json')
        
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            if module_name in modules:
                checklist = self.checklist_I if module_name == "Target application" else self.checklist_II
                for test_case in modules[module_name]['test_cases']:
                    test_case_box = TestCaseBox(test_case, checklist, self.workspace, parent=self)
                    self.test_case_layout.addWidget(test_case_box)
            
            # Add stretch to push boxes to the top
            self.test_case_layout.addStretch()

    def save_test_case(self, updated_test_case):
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            current_item = self.module_tree.currentItem()
            if current_item:
                current_module = current_item.data(0, Qt.ItemDataRole.UserRole)
                
                # Find and update the specific test case
                for i, test_case in enumerate(modules[current_module]['test_cases']):
                    if test_case['id'] == updated_test_case['id']:
                        modules[current_module]['test_cases'][i] = updated_test_case
                        break
                
                with open(module_file, 'w') as f:
                    json.dump(modules, f, indent=2)
                
                print(f"Test case '{updated_test_case['test case']}' updated successfully.")
                self.update_project_stats()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = ProjectManager()
    sys.exit(app.exec())
