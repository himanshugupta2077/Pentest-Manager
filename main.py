import sys, os, json, re, anthropic, uuid
from datetime import datetime
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
                             QPushButton, QFileDialog, QInputDialog, QLabel, QListWidget,
                             QSplitter, QFrame, QSizePolicy, QTreeWidget, QTreeWidgetItem, QCheckBox,
                             QScrollArea, QLineEdit, QFormLayout, QComboBox, QButtonGroup, QCompleter, QMessageBox,
                             QDialog, QTextEdit)
from PyQt6.QtCore import Qt, QTimer, QSettings
from PyQt6.QtGui import QIcon

class BulkTestCaseDialog(QDialog):
    def __init__(self, checklist, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Add Bulk Test Cases")
        self.layout = QVBoxLayout(self)

        self.checklist = {item[0]: item[1] for item in checklist}

        self.test_case_combo = QComboBox()
        self.test_case_combo.addItems([item[0] for item in checklist])
        self.test_case_combo.setEditable(True)
        self.layout.addWidget(QLabel("Test Case:"))
        self.layout.addWidget(self.test_case_combo)

        self.technique_edit = QLineEdit()
        self.layout.addWidget(QLabel("Technique:"))
        self.layout.addWidget(self.technique_edit)

        self.url_edit = QLineEdit()
        self.layout.addWidget(QLabel("URL:"))
        self.layout.addWidget(self.url_edit)

        self.locations_edit = QTextEdit()
        self.layout.addWidget(QLabel("Locations (one per line):"))
        self.layout.addWidget(self.locations_edit)

        self.comment_edit = QLineEdit()
        self.layout.addWidget(QLabel("Comment:"))
        self.layout.addWidget(self.comment_edit)

        self.outcome_edit = QLineEdit()
        self.layout.addWidget(QLabel("Outcome:"))
        self.layout.addWidget(self.outcome_edit)

        self.buttons = QHBoxLayout()
        self.ok_button = QPushButton("OK")
        self.cancel_button = QPushButton("Cancel")
        self.buttons.addWidget(self.ok_button)
        self.buttons.addWidget(self.cancel_button)
        self.layout.addLayout(self.buttons)

        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

        # Connect the test case combo box to update the technique
        self.test_case_combo.currentTextChanged.connect(self.update_technique)
        print("test")

    def update_technique(self, test_case):
        technique = self.checklist.get(test_case, '')
        self.technique_edit.setText(technique)

    def get_data(self):
        test_case = self.test_case_combo.currentText()
        return {
            'test_case': test_case,
            'technique': self.technique_edit.text(),
            'url': self.url_edit.text(),
            'locations': self.locations_edit.toPlainText().split('\n'),
            'comment': self.comment_edit.text(),
            'outcome': self.outcome_edit.text()
        }

class TestCaseBox(QFrame):
    def __init__(self, test_case_data, test_cases, workspace, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.test_case_data = test_case_data
        self.workspace = workspace
        self.setFrameStyle(QFrame.Shape.Box | QFrame.Shadow.Raised)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        
        self.setStyleSheet("""
            TestCaseBox {
                background-color: #555555;
                border: 1px #555555;
                border-radius: 5px;
            }
        """)
        
        main_layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        main_layout.addLayout(form_layout)
        
        self.fields = {}
        
        for field, value in test_case_data.items():
            if field not in ['created_at', 'completed_at', 'status', 'id', 'exported', 'module']:
                if field == 'test case':
                    combo = QComboBox()
                    combo.setEditable(True)
                    combo.addItems(test_cases)
                    if isinstance(value, list):
                        combo.setCurrentText(value[0] if value else '')
                    else:
                        combo.setCurrentText(value)
                    combo.setInsertPolicy(QComboBox.InsertPolicy.NoInsert)
                    combo.completer().setCompletionMode(QCompleter.CompletionMode.PopupCompletion)
                    form_layout.addRow(combo)
                    self.fields[field] = combo
                else:
                    line_edit = QLineEdit(str(value))  # Convert value to string
                    line_edit.setPlaceholderText(field.capitalize())
                    form_layout.addRow(line_edit)
                    self.fields[field] = line_edit
        
        bottom_layout = QHBoxLayout()
        bottom_layout.addStretch(1)
        
        copy_button = QPushButton("Make a copy")
        copy_button.clicked.connect(self.copy_test_case)
        copy_button.setFixedWidth(80)
        bottom_layout.addWidget(copy_button)
        
        self.status_button_group = QButtonGroup(self)
        self.not_done_button = QPushButton("Not done")
        self.completed_button = QPushButton("Completed")
        self.not_done_button.setCheckable(True)
        self.completed_button.setCheckable(True)
        self.not_done_button.setFixedWidth(80)
        self.completed_button.setFixedWidth(80)
        
        self.status_button_group.addButton(self.not_done_button)
        self.status_button_group.addButton(self.completed_button)
        
        bottom_layout.addWidget(self.not_done_button)
        bottom_layout.addWidget(self.completed_button)
        
        if test_case_data.get('status', "Not done") == "Not done":
            self.not_done_button.setChecked(True)
        else:
            self.completed_button.setChecked(True)
        
        self.status_button_group.buttonClicked.connect(self.on_status_changed)
        
        # Add export checkbox
        self.export_checkbox = QCheckBox("Exported")
        self.export_checkbox.setChecked(test_case_data.get('exported', False))
        self.export_checkbox.stateChanged.connect(self.on_export_changed)
        bottom_layout.addWidget(self.export_checkbox)
        
        save_button = QPushButton("Save")
        save_button.clicked.connect(self.save_changes)
        save_button.setFixedWidth(60)
        bottom_layout.addWidget(save_button)
        
        self.delete_button = QPushButton("Delete")
        self.delete_button.clicked.connect(self.delete_test_case)
        self.delete_button.setFixedWidth(60)
        bottom_layout.addWidget(self.delete_button)

        main_layout.addLayout(bottom_layout)

        self.update_appearance()

    def update_appearance(self):
        if self.test_case_data['status'] == "Completed":
            self.setStyleSheet("""
                TestCaseBox {
                    background-color: #90EE90;  /* Light green */
                    border: 1px solid #2E8B57;  /* Dark green border */
                    border-radius: 5px;
                }
            """)
        else:
            self.setStyleSheet("""
                TestCaseBox {
                    background-color: #555555;
                    border: 1px solid #555555;
                    border-radius: 5px;
                }
            """)

    def save_current_values(self):
        for field, widget in self.fields.items():
            if isinstance(widget, QComboBox):
                self.test_case_data[field] = widget.currentText()
            else:
                self.test_case_data[field] = widget.text()
        
        self.test_case_data['status'] = "Completed" if self.completed_button.isChecked() else "Not done"
        self.test_case_data['exported'] = self.export_checkbox.isChecked()
        
        if self.parent:
            self.parent.save_test_case(self.test_case_data)

    def on_export_changed(self, state):
        self.test_case_data['exported'] = state == Qt.CheckState.Checked.value
        self.save_changes()

    def copy_test_case(self):
        self.save_current_values()  # Save current values before copying
        new_test_case = self.test_case_data.copy()
        new_test_case['test case'] = f"{new_test_case['test case']}"
        new_test_case['created_at'] = datetime.now().isoformat()
        new_test_case['completed_at'] = None
        new_test_case['status'] = "Not done"
        new_test_case['id'] = str(uuid.uuid4())  # Generate a new unique ID for the copy
        
        if self.parent:
            self.parent.add_copied_test_case(new_test_case)

    def delete_test_case(self):
        if self.parent and self.parent.delete_mode:
            self.parent.delete_test_case(self.test_case_data['id'])
        else:
            reply = QMessageBox.question(self, 'Delete Test Case',
                                         f"Are you sure you want to delete the test case '{self.test_case_data['test case']}'?",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                         QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.Yes:
                self.parent.delete_test_case(self.test_case_data['id'])

    def on_status_changed(self, button):
        new_status = "Completed" if button == self.completed_button else "Not done"
        if new_status == "Completed":
            self.test_case_data['completed_at'] = datetime.now().isoformat()
        else:
            self.test_case_data['completed_at'] = ""  # Empty string instead of None
        self.test_case_data['status'] = new_status
        self.update_appearance()
        self.save_changes()

    def save_changes(self):
        for field, widget in self.fields.items():
            if isinstance(widget, QComboBox):
                self.test_case_data[field] = widget.currentText()
            else:
                self.test_case_data[field] = widget.text()
        
        if self.completed_button.isChecked():
            self.test_case_data['status'] = "Completed"
            if not self.test_case_data.get('completed_at'):
                self.test_case_data['completed_at'] = datetime.now().isoformat()
        else:
            self.test_case_data['status'] = "Not done"
            self.test_case_data['completed_at'] = ""  # Empty string instead of None
        
        self.test_case_data['exported'] = self.export_checkbox.isChecked()
        
        self.update_appearance()
        
        if self.parent:
            self.parent.save_test_case(self.test_case_data)
            self.parent.update_project_stats()

class ProjectManager(QMainWindow):
    def __init__(self):
        super().__init__()
        self.workspace = None
        self.project_name = None
        self.project_day = None
        self.checklist_I = self.load_checklist('checklist_I.txt')
        self.checklist_II = self.load_checklist('checklist_II.txt')
        self.delete_mode = False
        self.exportable_count = 0
        self.settings = QSettings("YourCompany", "ProjectManager")
        self.initUI()
        
        # Set up autosave timer
        self.autosave_timer = QTimer(self)
        self.autosave_timer.timeout.connect(self.autosave)
        self.autosave_timer.start(1000)  # 1000 ms = 1 second

        self.current_module = None
        self.save_timer = QTimer(self)
        self.save_timer.timeout.connect(self.save_current_module)
        self.save_timer.start(1000)

        # Maximize the window
        self.showMaximized()

        # Auto-trigger workspace selection after a short delay
        QTimer.singleShot(100, self.autoSelectWorkspace)

        # Apply the saved theme or default to system theme
        self.apply_theme(self.settings.value("theme", "system"))

    def save_current_module(self):
        if self.current_module and self.workspace:
            log_file = os.path.join(self.workspace, 'module_log.txt')
            with open(log_file, 'w') as f:
                f.write(self.current_module)

    def load_last_module(self):
        if self.workspace:
            log_file = os.path.join(self.workspace, 'module_log.txt')
            if os.path.exists(log_file):
                with open(log_file, 'r') as f:
                    last_module = f.read().strip()
                if last_module:
                    self.select_module(last_module)

    def select_module(self, module_name):
        for i in range(self.module_tree.topLevelItemCount()):
            item = self.module_tree.topLevelItem(i)
            if item.data(0, Qt.ItemDataRole.UserRole) == module_name:
                self.module_tree.setCurrentItem(item)
                self.on_module_clicked(item, 0)
                break

    def load_checklist(self, filename):
        checklist_path = os.path.join(os.path.dirname(__file__), filename)
        checklist = []
        if os.path.exists(checklist_path):
            with open(checklist_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line:
                        parts = line.split(':', 1)
                        title = parts[0].strip()
                        technique = parts[1].strip() if len(parts) > 1 else ""
                        checklist.append((title, technique))
        return checklist

    def autoSelectWorkspace(self):
        # Check if there's a last used workspace
        settings = QSettings("YourCompany", "ProjectManager")
        last_workspace = settings.value("last_workspace", "")

        if last_workspace and os.path.exists(last_workspace):
            self.workspace = last_workspace
            try:
                self.checkLogFile()
                self.loadModules()
                self.load_last_module()  # Load the last selected module
                self.update_project_stats()
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Error loading last workspace: {str(e)}")
                self.selectFolder()
        else:
            self.selectFolder()

    def anonymize_URLs(self, content):
        URL_pattern = re.compile(r'\*\*(.*?)\*\*')
        placeholders = {}
        
        def replace_URL(match):
            URL = match.group(1)
            placeholder = f'URL_PLACEHOLDER_{len(placeholders)}'
            placeholders[placeholder] = URL
            return placeholder
        
        anonymized_content = URL_pattern.sub(replace_URL, content)
        return anonymized_content, placeholders

    def process_with_anthropic(self, content, prompt):
        client = anthropic.Anthropic(api_key=os.environ.get('ANTHROPIC_API_KEY'))
        full_prompt = f"{prompt}\n\n{content}"
        message = client.messages.create(
            model="claude-3-5-sonnet-20240620",
            max_tokens=1000,
            temperature=0,
            messages=[
                {
                    "role": "user",
                    "content": full_prompt
                }
            ]
        )
        processed_content = message.content[0].text
        return processed_content

    def reinsert_URLs(self, content, placeholders):
        for placeholder, URL in placeholders.items():
            content = content.replace(placeholder, f"{URL}")
        content = re.sub(r'\n\n+', '\n', content)
        return content

    def write_and_process(self):
        if not self.workspace:
            QMessageBox.warning(self, "Error", "Please select a workspace first.")
            return

        try:
            # Get the list of exported files
            export_folder = os.path.join(self.workspace, 'Exported')
            exported_files = [f for f in os.listdir(export_folder) if f.startswith("entries_")]

            if not exported_files:
                QMessageBox.warning(self, "Error", "No exported files found.")
                return

            # Let user select an exported file
            selected_file, ok = QInputDialog.getItem(self, "Select Exported File", "Choose a file:", exported_files, 0, False)
            if not ok:
                return

            file_path = os.path.join(export_folder, selected_file)

            # Read the content
            with open(file_path, 'r') as f:
                content = f.read()

            # Anonymize URLs
            anonymized_content, placeholders = self.anonymize_URLs(content)

            # Get prompts from the prompts folder
            prompts_folder = os.path.join(os.path.dirname(__file__), 'prompts')
            prompts = [f for f in os.listdir(prompts_folder) if f.endswith('.txt')]

            if not prompts:
                QMessageBox.warning(self, "Error", "No prompts found in the prompts folder.")
                return

            # Let user select a prompt
            prompt, ok = QInputDialog.getItem(self, "Select Prompt", "Choose a prompt:", prompts, 0, False)
            if not ok:
                return

            # Read the selected prompt
            with open(os.path.join(prompts_folder, prompt), 'r') as f:
                prompt_content = f.read()

            # Process with Anthropic
            processed_content = self.process_with_anthropic(anonymized_content, prompt_content)

            # Reinsert URLs
            final_content = self.reinsert_URLs(processed_content, placeholders)

            # Save the output
            updates_folder = os.path.join(self.workspace, 'Updates')
            os.makedirs(updates_folder, exist_ok=True)
            output_file = f"update_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.txt"
            output_path = os.path.join(updates_folder, output_file)

            with open(output_path, 'w') as f:
                f.write(final_content)

            QMessageBox.information(self, "Success", f"Processed content saved to {output_path}")

        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred during processing: {str(e)}")
            print(f"Error in write_and_process: {str(e)}")

    def add_copied_test_case(self, new_test_case):
        current_item = self.module_tree.currentItem()
        if current_item:
            module_name = current_item.data(0, Qt.ItemDataRole.UserRole)
            self.save_modules(new_data=new_test_case, current_module_name=module_name)
            self.display_test_cases(module_name)  # Refresh the display
            self.update_project_stats()

    def update_project_stats(self):
        if not self.workspace:
            self.project_info_label.setText("No project selected")
            return

        total_cases = 0
        total_completed = 0
        module_file = os.path.join(self.workspace, 'modules.json')
        try:
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)
                
                for module_name, module_data in modules.items():
                    test_cases = module_data['test_cases']
                    cases_count = len(test_cases)
                    completed_count = sum(1 for case in test_cases if case['status'] == 'Completed')
                    total_cases += cases_count
                    total_completed += completed_count
                    
                    if cases_count > 0:
                        completion_percentage = round((completed_count / cases_count) * 100, 1)
                    else:
                        completion_percentage = 0
                    
                    module_item = self.find_module_item(module_name)
                    if module_item:
                        module_item.setText(0, f"{module_name} ({completion_percentage:.1f}%)")
                        module_item.setData(0, Qt.ItemDataRole.UserRole, module_name)
            
            if total_cases > 0:
                project_completion = round((total_completed / total_cases) * 100, 1)
            else:
                project_completion = 0
            
            self.update_header_info(total_cases, total_completed, project_completion)
            self.refresh_module_tree()
        except Exception as e:
            print(f"Error updating project stats: {str(e)}")
            self.project_info_label.setText("Error updating project stats")

    def refresh_module_tree(self):
        for i in range(self.module_tree.topLevelItemCount()):
            item = self.module_tree.topLevelItem(i)
            module_name = item.data(0, Qt.ItemDataRole.UserRole)
            self.update_module_percentage(item, module_name)

    def update_module_percentage(self, item, module_name):
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            if module_name in modules:
                test_cases = modules[module_name]['test_cases']
                cases_count = len(test_cases)
                completed_count = sum(1 for case in test_cases if case['status'] == 'Completed')
                
                if cases_count > 0:
                    completion_percentage = round((completed_count / cases_count) * 100, 1)
                else:
                    completion_percentage = 0
                
                item.setText(0, f"{module_name} ({completion_percentage:.1f}%)")


    def find_module_item(self, module_name):
        for i in range(self.module_tree.topLevelItemCount()):
            item = self.module_tree.topLevelItem(i)
            if item.data(0, Qt.ItemDataRole.UserRole) == module_name:
                return item
        return None

    def update_header_info(self, total_cases, total_completed, project_completion):
        today = datetime.now().date()
        completed_today = self.get_completed_today()
        self.exportable_count = self.get_exportable_count()
        
        header_text = (f"{today.strftime('%Y-%m-%d')} | "
                       f"{project_completion:.1f}% | "
                       f"Completed today: {completed_today}")
        
        self.project_info_label.setText(header_text)
        self.exportable_label.setText(f"Exportable: {self.exportable_count}")

    def get_exportable_count(self):
        exportable_count = 0
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            for module_name, module_data in modules.items():
                test_cases = module_data['test_cases']
                exportable_count += sum(1 for case in test_cases if case['status'] == 'Completed' and not case.get('exported', False))
        
        return exportable_count

    def get_completed_today(self):
        today = datetime.now().date()
        completed_today = 0
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            for module_name, module_data in modules.items():
                test_cases = module_data['test_cases']
                for case in test_cases:
                    if case['status'] == 'Completed' and case['completed_at']:
                        try:
                            completed_date = datetime.fromisoformat(case['completed_at']).date()
                            if completed_date == today:
                                completed_today += 1
                        except (ValueError, TypeError):
                            # If the date is invalid or None, skip this test case
                            continue
        
        return completed_today

    def delete_test_case(self, test_case_id):
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            for module_name, module_data in modules.items():
                module_data['test_cases'] = [tc for tc in module_data['test_cases'] if tc['id'] != test_case_id]
            
            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)
            
            current_item = self.module_tree.currentItem()
            if current_item:
                self.display_test_cases(current_item.data(0, Qt.ItemDataRole.UserRole))
            
            self.update_project_stats()

    def autosave(self):
        if self.workspace and self.project_name is not None and self.project_day is not None:
            try:
                self.save_modules()
                self.saveProjectInfo()
            except Exception as e:
                print(f"Autosave error: {str(e)}")

    def initUI(self):
        self.setWindowTitle('Project Manager')
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        # Top section (project info, buttons, and theme selection)
        top_frame = QFrame()
        top_frame.setFrameStyle(QFrame.Shape.Box | QFrame.Shadow.Raised)
        top_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        top_layout = QHBoxLayout(top_frame)
        top_layout.setContentsMargins(5, 5, 5, 5)
        top_layout.setSpacing(5)

        self.project_name_label = QLabel("")
        top_layout.addWidget(self.project_name_label)
        
        self.exportable_label = QLabel(f"Exportable: {self.exportable_count}")
        top_layout.addWidget(self.exportable_label)

        day_layout = QHBoxLayout()
        day_layout.setSpacing(2)
        self.project_day_label = QLabel("")
        day_layout.addWidget(self.project_day_label)
        self.project_day_edit = QLineEdit()
        self.project_day_edit.setFixedWidth(30)
        self.project_day_edit.editingFinished.connect(self.update_project_day)
        day_layout.addWidget(self.project_day_edit)
        top_layout.addLayout(day_layout)
        
        top_layout.addStretch(1)
        
        self.project_info_label = QLabel()
        self.select_folder_btn = QPushButton('Select WS')
        self.select_folder_btn.clicked.connect(self.selectFolder)
        self.select_folder_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.save_all_btn = QPushButton('Save All')
        self.save_all_btn.clicked.connect(self.save_all)
        self.save_all_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.export_btn = QPushButton('Export')
        self.export_btn.clicked.connect(self.export_completed_cases)
        self.export_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.write_btn = QPushButton('Write')
        self.write_btn.clicked.connect(self.write_and_process)
        self.write_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        
        self.delete_mode_btn = QPushButton('Delete Mode: OFF')
        self.delete_mode_btn.clicked.connect(self.toggle_delete_mode)
        self.delete_mode_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        
        self.open_folder_btn = QPushButton('Open Folder')
        self.open_folder_btn.clicked.connect(self.open_current_folder)
        self.open_folder_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        
        top_layout.addWidget(self.project_info_label)
        top_layout.addWidget(self.select_folder_btn)
        top_layout.addWidget(self.save_all_btn)
        top_layout.addWidget(self.export_btn)
        top_layout.addWidget(self.write_btn)
        top_layout.addWidget(self.delete_mode_btn)
        top_layout.addWidget(self.open_folder_btn)

        # Add theme selection buttons
        self.light_theme_btn = QPushButton()
        self.light_theme_btn.setIcon(QIcon.fromTheme('weather-clear'))
        self.light_theme_btn.setToolTip('Light Theme')
        self.light_theme_btn.clicked.connect(lambda: self.change_theme('light'))

        self.dark_theme_btn = QPushButton()
        self.dark_theme_btn.setIcon(QIcon.fromTheme('weather-clear-night'))
        self.dark_theme_btn.setToolTip('Dark Theme')
        self.dark_theme_btn.clicked.connect(lambda: self.change_theme('dark'))

        self.system_theme_btn = QPushButton()
        self.system_theme_btn.setIcon(QIcon.fromTheme('preferences-system'))
        self.system_theme_btn.setToolTip('System Theme')
        self.system_theme_btn.clicked.connect(lambda: self.change_theme('system'))

        top_layout.addWidget(self.light_theme_btn)
        top_layout.addWidget(self.dark_theme_btn)
        top_layout.addWidget(self.system_theme_btn)

        # Splitter for resizable left and right sections
        self.splitter = QSplitter(Qt.Orientation.Horizontal)

        # Left side (module tree)
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        self.module_tree = QTreeWidget()
        self.module_tree.setHeaderLabels(['Modules', ''])
        self.module_tree.setColumnWidth(0, 350)  # Increased width for modules
        # self.module_tree.setColumnWidth(1, 500)   # Decreased width for add button
        self.module_tree.itemClicked.connect(self.on_module_clicked)
        self.add_module_btn = QPushButton('Add Module')
        self.add_module_btn.clicked.connect(self.add_module)
        left_layout.addWidget(self.module_tree)
        left_layout.addWidget(self.add_module_btn)

        # Right side (test case boxes)
        self.right_widget = QScrollArea()
        self.right_widget.setWidgetResizable(True)
        self.test_case_container = QWidget()
        self.test_case_layout = QVBoxLayout(self.test_case_container)
        self.right_widget.setWidget(self.test_case_container)

        self.splitter.addWidget(left_widget)
        self.splitter.addWidget(self.right_widget)
        
        self.splitter.setSizes([300, 900])
        self.splitter.setStretchFactor(0, 1)
        self.splitter.setStretchFactor(1, 3)

        main_layout.addWidget(top_frame)
        main_layout.addWidget(self.splitter)

    def change_theme(self, theme):
        self.settings.setValue("theme", theme)
        self.apply_theme(theme)

    def apply_theme(self, theme):
        if theme == 'light':
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #f0f0f0;
                    color: #000000;
                }
                QTreeWidget, QListWidget {
                    background-color: #ffffff;
                    color: #000000;
                }
                QPushButton {
                    background-color: #e0e0e0;
                    color: #000000;
                }
            """)
        elif theme == 'dark':
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #2b2b2b;
                    color: #ffffff;
                }
                QTreeWidget, QListWidget {
                    background-color: #3c3f41;
                    color: #ffffff;
                }
                QPushButton {
                    background-color: #4b6eaf;
                    color: #ffffff;
                }
            """)
        else:  # system theme
            self.setStyleSheet("")

    def open_current_folder(self):
        if self.workspace:
            os.startfile(self.workspace)
        else:
            QMessageBox.warning(self, "Warning", "No workspace selected.")

    def toggle_delete_mode(self):
        self.delete_mode = not self.delete_mode
        if self.delete_mode:
            self.delete_mode_btn.setText('Delete Mode: ON')
            self.delete_mode_btn.setStyleSheet('background-color: red;')
        else:
            self.delete_mode_btn.setText('Delete Mode: OFF')
            self.delete_mode_btn.setStyleSheet('')

    def update_project_day(self):
        try:
            new_day = int(self.project_day_edit.text())
            self.project_day = new_day
            self.saveProjectInfo()
            self.updateProjectInfo()
        except ValueError:
            QMessageBox.warning(self, "Invalid Input", "Please enter a valid number for the project day.")
            self.project_day_edit.setText(str(self.project_day))

    def export_completed_cases(self):
        if not self.workspace:
            QMessageBox.warning(self, "Export Error", "Please select a workspace first.")
            return

        today = datetime.now()
        completed_cases = []

        module_file = os.path.join(self.workspace, 'modules.json')
        try:
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)

                for module_name, module_data in modules.items():
                    for test_case in module_data['test_cases']:
                        if test_case['status'] == 'Completed' and not test_case.get('exported', False):
                            test_case_copy = test_case.copy()
                            test_case_copy['module'] = module_name
                            completed_cases.append(test_case_copy)

            if not completed_cases:
                QMessageBox.information(self, "Export Info", "No new completed test cases to export.")
                return

            # Create Exported folder if it doesn't exist
            export_folder = os.path.join(self.workspace, 'Exported')
            os.makedirs(export_folder, exist_ok=True)

            # Updated filename format
            filename = f"entries_{today.strftime('%Y-%m-%d_%H-%M-%S')}_{len(completed_cases)}.txt"
            filepath = os.path.join(export_folder, filename)

            # Use a default prompt file instead of asking the user to select one
            default_prompt_file = os.path.join(os.path.dirname(__file__), 'prompts', 'default_prompt.txt')
            
            with open(filepath, 'w') as f:
                # Write the default prompt at the beginning of the file
                if os.path.exists(default_prompt_file):
                    with open(default_prompt_file, 'r') as pf:
                        f.write(pf.read())
                        f.write("\n\n")  # Add some space after the prompt

                for i, case in enumerate(completed_cases, 1):
                    f.write(f"Entry {i}:\n")
                    f.write(f"Testcase: {case.get('test case', 'N/A')}\n")
                    f.write(f"URL: **{case.get('URL', 'N/A')}**\n")
                    f.write(f"Location: {case.get('location', 'N/A')}\n")
                    f.write(f"Module: {case.get('module', 'N/A')}\n")
                    f.write(f"Technique: {case.get('technique', 'N/A')}\n")
                    f.write(f"Comment: {case.get('comment', 'N/A')}\n")
                    f.write(f"Outcome: {case.get('outcome', 'N/A')}\n")
                    f.write("\n")

            # Mark exported cases as exported
            for module_name, module_data in modules.items():
                for test_case in module_data['test_cases']:
                    if test_case['status'] == 'Completed' and not test_case.get('exported', False):
                        test_case['exported'] = True

            # Save the updated modules
            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)

            QMessageBox.information(self, "Export Successful", f"Exported {len(completed_cases)} completed test cases to Exported/{filename}")
            
            # Refresh the current module display
            current_item = self.module_tree.currentItem()
            if current_item:
                current_module = current_item.data(0, Qt.ItemDataRole.UserRole)
                self.display_test_cases(current_module)
            
            self.update_project_stats()
        except Exception as e:
            print(f"Error exporting completed cases: {str(e)}")
            QMessageBox.warning(self, "Export Error", f"Could not export completed cases: {str(e)}")

    def load_test_cases(self):
        checklist_path = os.path.join(os.path.dirname(__file__), 'checklist_I.txt')
        if os.path.exists(checklist_path):
            with open(checklist_path, 'r') as f:
                return [line.strip() for line in f if line.strip()]
        return []

    def save_all(self):
        if self.current_module:
            self.save_all_test_cases()
        self.save_modules()
        self.saveProjectInfo()
        self.update_project_stats()
        print("All changes saved manually.")
        # QMessageBox.information(self, "Save Successful", "All changes have been saved successfully.")

    def selectFolder(self):
        try:
            folder = QFileDialog.getExistingDirectory(self, "Select Workspace Folder")
            if folder:
                self.workspace = folder
                # Save the selected workspace for future use
                settings = QSettings("YourCompany", "ProjectManager")
                settings.setValue("last_workspace", self.workspace)

                print("Checking log file...")
                self.checkLogFile()
                print("Loading modules...")
                self.loadModules()
                print("Updating project stats...")
                self.update_project_stats()
            else:
                print("No workspace selected.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while selecting the workspace: {str(e)}")
            print(f"Error in selectFolder: {str(e)}")
            import traceback
            traceback.print_exc()

    def checkLogFile(self):
        log_file = os.path.join(self.workspace, 'project_log.txt')
        if os.path.exists(log_file):
            try:
                with open(log_file, 'r') as f:
                    content = f.read().strip().split(',')
                    self.project_name = content[0]
                    self.project_day = int(content[1])
                    last_date = datetime.strptime(content[2], '%Y-%m-%d').date() if len(content) > 2 else datetime.now().date()
                
                today = datetime.now().date()
                if today > last_date:
                    self.project_day += 1
                    self.saveProjectInfo()
                
                self.updateProjectInfo()
            except (IndexError, ValueError):
                self.getProjectInfo()
        else:
            self.getProjectInfo()

    def getProjectInfo(self):
        project_name, ok = QInputDialog.getText(self, 'Project Name', 'Enter project name:')
        if ok:
            project_day, ok = QInputDialog.getInt(self, 'Project Day', 'Enter project day:')
            if ok:
                self.project_name = project_name
                self.project_day = project_day
                self.saveProjectInfo()
                self.updateProjectInfo()
                
                # Create default "Target application" module with test cases from checklist_I
                self.add_module_to_tree("Target application")
                self.create_default_test_cases("Target application", self.checklist_I)
                self.select_module("Target application")  # Select the default module

    def create_default_test_cases(self, module_name, checklist):
        new_test_cases = []
        for test_case_name in checklist:
            new_test_case = {
                'test case': test_case_name,
                'URL': '',
                'location': '',
                'technique': '',
                'comment': '',
                'outcome': '',
                'created_at': datetime.now().isoformat(),
                'completed_at': None,
                'status': "Not done",
                'id': str(uuid.uuid4())
            }
            new_test_cases.append(new_test_case)
        
        self.save_modules(new_data=new_test_cases, current_module_name=module_name)
        self.display_test_cases(module_name)
        self.update_project_stats()

    def saveProjectInfo(self):
        if not self.workspace or self.project_name is None or self.project_day is None:
            print("Project information is incomplete. Cannot save.")
            return

        log_file = os.path.join(self.workspace, 'project_log.txt')
        today = datetime.now().date()
        try:
            with open(log_file, 'w') as f:
                f.write(f"{self.project_name},{self.project_day},{today}")
        except IOError as e:
            print(f"Error saving project info: {str(e)}")
            QMessageBox.warning(self, "Save Error", f"Could not save project info: {str(e)}")

    def updateProjectInfo(self):
        if self.project_name:
            self.project_name_label.setText(f"{self.project_name}")
            self.setWindowTitle(f"TCM - {self.project_name}")  # Update window title
        if self.project_day is not None:
            self.project_day_edit.setText(str(self.project_day))

    def loadModules(self):
        try:
            module_file = os.path.join(self.workspace, 'modules.json')
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)
                self.module_tree.clear()
                for module_name, module_data in modules.items():
                    self.add_module_to_tree(module_name, module_data)
            self.update_project_stats()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while loading modules: {str(e)}")
            print(f"Error in loadModules: {str(e)}")

    def add_module(self):
        try:
            module_name, ok = QInputDialog.getText(self, 'Add Module', 'Enter module name:')
            if ok and module_name:
                module_id = str(uuid.uuid4())  # Generate a unique ID for the new module
                self.add_module_to_tree(module_name)
                self.save_modules(new_module=module_name, module_id=module_id)
            self.update_project_stats()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while adding a module: {str(e)}")
            print(f"Error in add_module: {str(e)}")

    def add_module_to_tree(self, module_name, module_data=None):
        module_item = QTreeWidgetItem(self.module_tree, [module_name])
        module_item.setData(0, Qt.ItemDataRole.UserRole, module_name)
        
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0, 0, 0, 0)
        button_layout.setSpacing(2)
        
        add_btn = QPushButton()
        add_btn.setIcon(QIcon.fromTheme('list-add'))
        add_btn.setFixedSize(24, 24)
        add_btn.clicked.connect(lambda: self.add_fields_to_module(module_item))
        
        bulk_add_btn = QPushButton()
        bulk_add_btn.setIcon(QIcon.fromTheme('edit-copy'))
        bulk_add_btn.setFixedSize(24, 24)
        bulk_add_btn.clicked.connect(lambda: self.add_bulk_test_cases(module_item))
        
        delete_btn = QPushButton()
        delete_btn.setIcon(QIcon.fromTheme('edit-delete'))
        delete_btn.setFixedSize(24, 24)
        delete_btn.clicked.connect(lambda: self.delete_module(module_item))
        
        button_layout.addWidget(add_btn)
        button_layout.addWidget(bulk_add_btn)
        button_layout.addWidget(delete_btn)
        
        button_widget = QWidget()
        button_widget.setLayout(button_layout)
        
        self.module_tree.setItemWidget(module_item, 1, button_widget)

    def add_bulk_test_cases(self, module_item):
        module_name = module_item.data(0, Qt.ItemDataRole.UserRole)
        checklist = self.checklist_I if module_name == "Target application" else self.checklist_II
        
        dialog = BulkTestCaseDialog(checklist, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            data = dialog.get_data()
            new_test_cases = []
            
            for location in data['locations']:
                if location.strip():  # Ignore empty lines
                    new_test_case = {
                        'test case': data['test_case'],
                        'technique': data['technique'],
                        'URL': data['url'],
                        'location': location.strip(),
                        'comment': data['comment'],
                        'outcome': data['outcome'],
                        'created_at': datetime.now().isoformat(),
                        'completed_at': None,
                        'status': "Not done",
                        'id': str(uuid.uuid4()),
                        'exported': False
                    }
                    new_test_cases.append(new_test_case)
            
            if new_test_cases:
                self.save_modules(new_data=new_test_cases, current_module_name=module_name)
                self.display_test_cases(module_name)
                self.update_project_stats()
                QMessageBox.information(self, "Bulk Add Successful", f"Added {len(new_test_cases)} new test cases.")
            else:
                QMessageBox.warning(self, "No Test Cases Added", "No valid locations were provided.")

    def delete_module(self, module_item):
        module_name = module_item.data(0, Qt.ItemDataRole.UserRole)
        reply = QMessageBox.warning(
            self,
            "Delete Module",
            f"<font color='red'>Warning: This will delete all test cases in the module '{module_name}'.</font><br><br>Are you sure you want to proceed?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            module_file = os.path.join(self.workspace, 'modules.json')
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)
                
                if module_name in modules:
                    del modules[module_name]
                    
                    with open(module_file, 'w') as f:
                        json.dump(modules, f, indent=2)
                    
                    # Remove the module from the tree
                    root = self.module_tree.invisibleRootItem()
                    root.removeChild(module_item)
                    
                    self.update_project_stats()
                    QMessageBox.information(self, "Module Deleted", f"Module '{module_name}' has been deleted.")
                else:
                    QMessageBox.warning(self, "Error", f"Module '{module_name}' not found.")
            else:
                QMessageBox.warning(self, "Error", "Module file not found.")

    def add_fields_to_module(self, module_item):
        module_name = module_item.data(0, Qt.ItemDataRole.UserRole)
        
        checklist = self.checklist_I if module_name == "Target application" else self.checklist_II
        
        test_cases = [item[0] for item in checklist]
        test_case, ok = QInputDialog.getItem(self, 'Add Test Case', 'Select or enter test case:', test_cases, 0, True)
        
        if ok and test_case:
            technique = next((item[1] for item in checklist if item[0] == test_case), '')
            new_data = {
                'test case': test_case, 
                'technique': technique,
                'URL': '',
                'location': '',
                'comment': '',
                'outcome': ''
            }
            
            # Add metadata
            new_data['created_at'] = datetime.now().isoformat()
            new_data['completed_at'] = None
            new_data['status'] = "Not done"
            new_data['id'] = str(uuid.uuid4())
            new_data['exported'] = False
            
            self.save_modules(new_data=new_data, current_module_name=module_name)
            self.display_test_cases(module_name)
        self.update_project_stats()

    def save_modules(self, new_data=None, current_module_name=None, new_module=None, module_id=None):
        if not self.workspace:
            QMessageBox.warning(self, "Warning", "No workspace selected. Cannot save modules.")
            return

        try:
            module_file = os.path.join(self.workspace, 'modules.json')
            
            if os.path.exists(module_file):
                with open(module_file, 'r') as f:
                    modules = json.load(f)
            else:
                modules = {}

            if new_module:
                if new_module not in modules:
                    modules[new_module] = {'id': module_id, 'test_cases': []}

            if new_data and current_module_name:
                if current_module_name not in modules:
                    modules[current_module_name] = {'id': str(uuid.uuid4()), 'test_cases': []}
                if isinstance(new_data, list):
                    modules[current_module_name]['test_cases'].extend(new_data)
                else:
                    modules[current_module_name]['test_cases'].append(new_data)

            with open(module_file, 'w') as f:
                json.dump(modules, f, indent=2)

            self.update_project_stats()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while saving modules: {str(e)}")
            print(f"Error in save_modules: {str(e)}")

    def on_module_clicked(self, item, column):
        if self.current_module:
            self.save_all_test_cases()
        module_name = item.data(0, Qt.ItemDataRole.UserRole)
        self.current_module = module_name
        self.display_test_cases(module_name)

    def save_all_test_cases(self):
        for i in range(self.test_case_layout.count()):
            item = self.test_case_layout.itemAt(i)
            if item.widget():
                test_case_box = item.widget()
                test_case_box.save_changes()

    def display_test_cases(self, module_name):
        while self.test_case_layout.count():
            item = self.test_case_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        module_file = os.path.join(self.workspace, 'modules.json')
        
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            if module_name in modules:
                checklist = self.checklist_I if module_name == "Target application" else self.checklist_II
                test_cases = [item[0] for item in checklist]  # Extract the first element of each tuple
                for test_case in modules[module_name]['test_cases']:
                    # Ensure 'test case' is a string
                    if isinstance(test_case.get('test case'), list):
                        test_case['test case'] = test_case['test case'][0] if test_case['test case'] else ''
                    test_case_box = TestCaseBox(test_case, test_cases, self.workspace, parent=self)
                    self.test_case_layout.addWidget(test_case_box)
            
            # Add stretch to push boxes to the top
            self.test_case_layout.addStretch()

        # Turn off scrolling for test case titles
        self.right_widget.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOn)
        self.right_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)

    def save_test_case(self, updated_test_case):
        module_file = os.path.join(self.workspace, 'modules.json')
        if os.path.exists(module_file):
            with open(module_file, 'r') as f:
                modules = json.load(f)
            
            current_item = self.module_tree.currentItem()
            if current_item:
                current_module = current_item.data(0, Qt.ItemDataRole.UserRole)
                
                # Find and update the specific test case
                for i, test_case in enumerate(modules[current_module]['test_cases']):
                    if test_case['id'] == updated_test_case['id']:
                        modules[current_module]['test_cases'][i] = updated_test_case
                        break
                
                with open(module_file, 'w') as f:
                    json.dump(modules, f, indent=2)
                
                print(f"Test case '{updated_test_case['test case']}' updated successfully.")
                self.update_project_stats()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = ProjectManager()
    sys.exit(app.exec())
