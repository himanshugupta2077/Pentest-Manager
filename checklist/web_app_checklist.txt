XSS: By injecting malicious scripts and payloads like '<script>alert('XSS')</script>' into input fields and observing if the application is executing them.
SQL_injection: By injecting SQL statements and payloads like '' OR '1'='1' and ''; DROP TABLE users;--' into respective input fields and and checking if the application executes them or responds with any errors. 
Broken_access_control: By attempting to access resources or perform actions beyond a user's permissions, by manipulating URLs, parameters, or using alternative paths to bypass access control mechanisms, and verifying if restricted data or functions can be accessed.
Privilege_escalation: By attempting to gain higher privileges within the application and trying to exploiting vulnerabilities in role-based access controls, manipulating session tokens, or leveraging application flaws to elevate the user’s privileges from a lower to a higher role.
IDOR: By changing resource identifiers in requests and checking if the application improperly exposes data or functionalities belonging to other users and by verifying if unauthorized access to data occurs due to Insecure Direct Object References.
Directory_enumeration: By attempting to list directories and files on the server by accessing common paths like '/admin', '/backup', '/config', etc and verifying if the application improperly discloses directory contents or sensitive files.
Forced_browsing: By accessing URLs and resources directly without using the application's navigation and by verifying if the application allows unauthorized access to pages and functionalities through URL manipulation and bypassing security controls.
Parameter_tampering: By modifying parameters in HTTP requests and observing if the application processes them without validation and verifying if manipulating these parameters leads to unauthorized actions or information disclosure.
Path_traversal: By using traversal sequences like '../' in input fields or URLs to access files outside the intended directory and verifying if the application allows accessing restricted directories or files on the server.
Weak_authentication_in_alternative_channel: By testing authentication mechanisms in alternative channels (e.g., mobile apps, APIs) and checking if they have weaker security compared to the main application and verifying if credentials or tokens are transmitted insecurely or if multi-factor authentication is not enforced.
CSRF: By creating malicious requests that automatically execute actions on behalf of an authenticated user without their consent.
HTTP_parameter_pollution: By injecting multiple parameters with the same name in a single request and checking if the application processes them improperly and verifying if the application’s behavior changes, leading to vulnerabilities like SQL injection, XSS, or logical flaws.
LDAP_injection: By injecting LDAP statements into input fields and checking if the application processes them without validation and using payloads like '*)(uid=*)' or '(|(objectClass=*))' and observing if the LDAP queries are modified or result in unauthorized access.
XML_Injection: By injecting XML data into input fields or request bodies and checking if the application processes them improperly and by also verifying if injecting malicious XML payloads leads to data extraction, modification, or application crashes.
Server_side_includes: By injecting server-side include directives (e.g., '<!--#exec cmd="ls"-->') into input fields or request bodies and checking if the application processes them.
XPATH_Injection: By injecting XPATH statements using payloads like '' or '1'='1' into input fields and checking if the application processes them without validation.
IMAP_SMTP_injection: By injecting IMAP/SMTP commands and using payloads like 'A001 LOGIN admin pass' into input fields used for email processing and checking if the application executes them.
File_inclusion: By manipulating respective parameters and checking if the application includes and processes files from unintended directories.
OS_command_injection: By injecting operating system commands and payloads like '; ls -la' or '&& cat /etc/passwd' into input fields and checking if the application executes them.
Format_string_injection: By injecting format string specifiers (e.g., '%x', '%s') into input fields and checking if the application processes them improperly and exposes memory content or crashes, indicating a format string vulnerability.
Host_header_injection: By manipulating the 'Host' header in HTTP requests and checking if the application processes it improperly.
SSRF: By crafting requests that force the server to make HTTP requests to internal or external systems and checking if the application exposes internal services, sensitive data, or allows unauthorized actions.
Server_side_template_injection: By injecting various template syntax such as '{{7*7}}' into input fields and checking if the server processes them.
Test_business_logic: By analyzing the application's business logic to identify flaws that could be exploited and verifying if logical steps in processes can be bypassed, manipulated, or abused.
URL_redirect: By manipulating URLs and parameters that control redirections and checking if the application improperly redirects users to malicious sites.
Clickjacking: By embedding the application in an iframe and crafting an overlay to trick users into clicking on hidden elements.
No_rate_limiting: By performing repeated requests in a short period to test for rate limiting mechanisms and verifying if the application lacks rate limiting which can lead to brute-force attacks, denial of service and abuse of functionalities.
EXIF_geodata: By uploading images with embedded EXIF metadata and checking if the application processes or exposes this data which can lead to privacy risks.
Weak_2FA: By analyzing the implementation of two-factor authentication mechanisms and verifying if the 2FA process can be easily bypassed.
Weak_OTP_implementation: By analyzing the One-Time Password (OTP) implementation for security flaws and verifying if the OTPs are predictable, reused, or transmitted insecurely.
file_upload_vulnerabilities: By attempting to upload files with various extensions '.php' and '.exe' and a malicious EICAR file to check if the application allows the upload without proper validation or sanitization.
web_osint: By using search engines, social media platforms, and public databases to gather information about the target organization, its employees, and infrastructure. This includes examining public GitHub repositories, LinkedIn profiles, and job postings for potentially sensitive information or technical details that could be exploited.
web_app_metafile_search: By searching and analyzing common metadata files such as robots.txt, sitemap.xml, and .well-known directories which may reveal hidden directories, API endpoints, or other sensitive information not intended for public access.
nmap: By performing port scans using various Nmap techniques such as SYN scans, UDP scans, and version detection scans and also using Nmap scripts to perform more targeted checks for known vulnerabilities.
web_server_enumeration: By analyzing HTTP response headers, server banners, and error messages to determine the web server type and version. This information can be used to research known vulnerabilities for the specific server software.
review_web_page_content_for_information_leakage: By manually inspecting HTML source code, JavaScript files, and comments for hardcoded credentials, API keys, or internal IP addresses. This also involves checking for excessive information in error messages that might reveal system details or database structure.
technology_and_framework_profiling: By analyzing HTTP headers, HTML source code, and JavaScript files to identify technologies and frameworks used in the web application. Also involves using tools like Wappalyzer or builtwith.com to automate the identification process and determine versions of detected technologies.
katana: By utilizing the Katana crawler tool to recursively crawl the target web application, discovering hidden endpoints, parameters, and potential entry points for attacks.
default_logins: By attempting to authenticate using commonly known default credentials which includes trying username/password combinations like admin/admin, root/root, or vendor-specific defaults.
missing_security_headers: By examining HTTP response headers for the absence of important security headers such as Content-Security-Policy, X-Frame-Options, X-XSS-Protection, and Strict-Transport-Security.
weak_HTTP_methods: By testing the web server's response to various HTTP methods, particularly focusing on potentially dangerous methods like PUT, DELETE, TRACE, and OPTIONS. This includes attempting to use these methods to modify or delete resources, or to gather information about the server's configuration.
HTTP_method_overriding: By checking if the application allows HTTP method overriding via headers like 'X-HTTP-Method-Override' or query parameters such as '_method'. By also sending a POST request with the 'X-HTTP-Method-Override' header set to 'PUT' or 'DELETE', and observing if the server processes the request with the overridden method.
Subdomain_takeover: By identifying subdomains of the target application that point to non-existent resources (e.g., non-configured AWS S3 buckets, GitHub pages, Heroku apps) and then registering a service that the subdomain points to and verifying control over the subdomain by creating a specific file or record and accessing it.
Cloud_storage: By checking if cloud storage buckets (e.g., AWS S3, Google Cloud Storage) are publicly accessible or misconfigured and by accessing known or guessed bucket names and listing contents, uploading, or downloading files to confirm misconfiguration.
Test_user_registration_process: By registering a new user account and checking if the process lacks proper validation and security checks.
Account_enumeration: By testing for differences in application responses when submitting valid vs. invalid usernames during login, password reset, or registration processes. By also analyzing the HTTP responses, error messages, or timing differences to determine if valid usernames can be identified.
Weak_lockout_mechanism: By attempting multiple failed login attempts and observing if the account gets locked after a certain number of attempts and by checking if the lockout mechanism can be easily bypassed by changing IP addresses or if the lockout duration is too short, allowing for brute-force attacks.
Multiple_logins: By logging into the same account from multiple devices or sessions simultaneously. By checking if the application allows multiple active sessions without notifying the user or without terminating previous sessions, which can lead to session hijacking risks.
Weak_password_policy: By registering a new account or changing the password and checking if the application enforces a strong password policy. By attempting to use weak passwords such as "123456" or "password" and verifying if these are accepted, indicating insufficient complexity requirements.
Weak_password_reset: By initiating the password reset process and checking for security flaws and verifying if the reset tokens are predictable, if the reset links are sent over insecure channels.
Weak_password_change: By changing the password of an existing account and checking if the application requires the current password before allowing the change.
Back_refresh_attack: By performing sensitive actions in a web application (e.g., updating profile information) and then navigating back in the browser or refreshing the page and checking if the application allows these actions to be repeated or viewed without re-authentication.
Test_logout_functionality: By logging out from the application and verifying if all sessions are properly terminated. By also checking if cookies or session tokens are invalidated.
Weak_transport_layer_security: By inspecting the application's implementation of SSL/TLS and checking for outdated or weak ciphers, the use of self-signed certificates, or the lack of HTTPS altogether.
CORS_misconfiguration: By checking if Access-Control-Allow-Origin header is set to * in the HTTP response which would indicate that the application is accepitng Origin from any third party site and by also modifying/creating the Origin header to evil.com and checking if the application reflects the modified URL in the HTTP response.
Broken_link_hijack: By identifying broken links within the application that point to non-existent resources.
DNS_records: By enumerating DNS records for the target domain using tools like 'dig', 'nslookup', and 'DNSDumpster' and identifying misconfigurations, outdated records, or unnecessary exposure of internal records that could be leveraged for attacks.
Weak_JWT_implementation: By inspecting the JSON Web Tokens (JWTs) used in the application for security flaws by checking if the tokens use weak algorithms (e.g., 'none' or 'HS256' with a weak secret), have long expiration times, or are improperly signed. Also Attempting token forgery or manipulation to bypass authentication or authorization.
Session_hijack: By capturing session tokens through methods such as XSS, MITM attacks, or insecure storage and using the captured token to hijack an active session and gain unauthorized access to the application.
Session_id_prediction: By analyzing the session IDs issued by the application for patterns or predictability and attempting to guess and brute-force valid session IDs.
Test_session_management_schema: By evaluating the session management practices of the application and checking for secure cookie attributes (e.g., HttpOnly, Secure, SameSite) and proper session expiration.
Session_fixation: By setting a session ID in advance (e.g., via a URL parameter or cookie) and checking if the application accepts and uses this session ID after login. By verifying if the session ID remains unchanged after authentication, potentially allowing an attacker to hijack the session.
Test_for_exposed_session_variables: By inspecting client-side storage mechanisms (e.g., cookies, local storage, session storage) for session-related variables and verifying if sensitive session information is exposed.
Session_timeout: By logging into the application and remaining idle for an extended period and then verifying if the session automatically expires and logs the user out after a certain period of inactivity, ensuring that sessions are not kept alive indefinitely.
Test_for_session_puzzling: By attempting to perform actions in an unintended order or concurrently to confuse the application's session handling logic and checking if this leads to unauthorized access or data corruption due to improper session state management.
Vulnerable_remember_password: By checking if the "Remember Me" functionality stores credentials or session tokens insecurely and verifying if sensitive information is stored in plaintext or with weak encryption in cookies or local storage, potentially exposing it to attackers.
Browser_cache_weakness: By inspecting the caching headers and behavior of the application and checking if sensitive data (e.g., session tokens, personal information) is cached by the browser, which could be accessed by other users or through local file access.
Nuclei_scan: By using Nuclei, a configurable vulnerability scanner, to scan the application. By creating or using existing templates to identify known vulnerabilities and misconfigurations in the application's infrastructure and code.
Burp_active_scan: By using Burp Suite's active scanning functionality to test the application for vulnerabilities. By configuring the scanner to thoroughly probe for common web application vulnerabilities, such as SQL injection, XSS, and insecure deserialization.
OWASP_ZAP_active_scan: By using OWASP ZAP's active scanning capabilities to assess the application's security. By running a comprehensive scan to identify issues like insecure authentication, broken access controls, and other OWASP Top 10 vulnerabilities.