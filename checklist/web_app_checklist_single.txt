web_osint: By using search engines, social media platforms, and public databases to gather information about the target organization, its employees, and infrastructure. This includes examining public GitHub repositories, LinkedIn profiles, and job postings for potentially sensitive information or technical details that could be exploited.
web_app_metafile_search: By searching and analyzing common metadata files such as robots.txt, sitemap.xml, and .well-known directories which may reveal hidden directories, API endpoints, or other sensitive information not intended for public access.
nmap: By performing port scans using various Nmap techniques such as SYN scans, UDP scans, and version detection scans and also using Nmap scripts to perform more targeted checks for known vulnerabilities.
web_server_enumeration: By analyzing HTTP response headers, server banners, and error messages to determine the web server type and version. This information can be used to research known vulnerabilities for the specific server software.
review_web_page_content_for_information_leakage: By manually inspecting HTML source code, JavaScript files, and comments for hardcoded credentials, API keys, or internal IP addresses. This also involves checking for excessive information in error messages that might reveal system details or database structure.
technology_and_framework_profiling: By analyzing HTTP headers, HTML source code, and JavaScript files to identify technologies and frameworks used in the web application. Also involves using tools like Wappalyzer or builtwith.com to automate the identification process and determine versions of detected technologies.
katana: By utilizing the Katana crawler tool to recursively crawl the target web application, discovering hidden endpoints, parameters, and potential entry points for attacks.
default_logins: By attempting to authenticate using commonly known default credentials which includes trying username/password combinations like admin/admin, root/root, or vendor-specific defaults.
missing_security_headers: By examining HTTP response headers for the absence of important security headers such as Content-Security-Policy, X-Frame-Options, X-XSS-Protection, and Strict-Transport-Security.
weak_HTTP_methods: By testing the web server's response to various HTTP methods, particularly focusing on potentially dangerous methods like PUT, DELETE, TRACE, and OPTIONS. This includes attempting to use these methods to modify or delete resources, or to gather information about the server's configuration.
HTTP_method_overriding: By checking if the application allows HTTP method overriding via headers like 'X-HTTP-Method-Override' or query parameters such as '_method'. By also sending a POST request with the 'X-HTTP-Method-Override' header set to 'PUT' or 'DELETE', and observing if the server processes the request with the overridden method.
Subdomain_takeover: By identifying subdomains of the target application that point to non-existent resources (e.g., non-configured AWS S3 buckets, GitHub pages, Heroku apps) and then registering a service that the subdomain points to and verifying control over the subdomain by creating a specific file or record and accessing it.
Cloud_storage: By checking if cloud storage buckets (e.g., AWS S3, Google Cloud Storage) are publicly accessible or misconfigured and by accessing known or guessed bucket names and listing contents, uploading, or downloading files to confirm misconfiguration.
Test_user_registration_process: By registering a new user account and checking if the process lacks proper validation and security checks.
Account_enumeration: By testing for differences in application responses when submitting valid vs. invalid usernames during login, password reset, or registration processes. By also analyzing the HTTP responses, error messages, or timing differences to determine if valid usernames can be identified.
Weak_lockout_mechanism: By attempting multiple failed login attempts and observing if the account gets locked after a certain number of attempts and by checking if the lockout mechanism can be easily bypassed by changing IP addresses or if the lockout duration is too short, allowing for brute-force attacks.
Multiple_logins: By logging into the same account from multiple devices or sessions simultaneously. By checking if the application allows multiple active sessions without notifying the user or without terminating previous sessions, which can lead to session hijacking risks.
Weak_password_policy: By registering a new account or changing the password and checking if the application enforces a strong password policy. By attempting to use weak passwords such as "123456" or "password" and verifying if these are accepted, indicating insufficient complexity requirements.
Weak_password_reset: By initiating the password reset process and checking for security flaws and verifying if the reset tokens are predictable, if the reset links are sent over insecure channels.
Weak_password_change: By changing the password of an existing account and checking if the application requires the current password before allowing the change.
Back_refresh_attack: By performing sensitive actions in a web application (e.g., updating profile information) and then navigating back in the browser or refreshing the page and checking if the application allows these actions to be repeated or viewed without re-authentication.
Test_logout_functionality: By logging out from the application and verifying if all sessions are properly terminated. By also checking if cookies or session tokens are invalidated.
Weak_transport_layer_security: By inspecting the application's implementation of SSL/TLS and checking for outdated or weak ciphers, the use of self-signed certificates, or the lack of HTTPS altogether.
CORS_misconfiguration: By checking if Access-Control-Allow-Origin header is set to * in the HTTP response which would indicate that the application is accepitng Origin from any third party site and by also modifying/creating the Origin header to evil.com and checking if the application reflects the modified URL in the HTTP response.
Broken_link_hijack: By identifying broken links within the application that point to non-existent resources.
DNS_records: By enumerating DNS records for the target domain using tools like 'dig', 'nslookup', and 'DNSDumpster' and identifying misconfigurations, outdated records, or unnecessary exposure of internal records that could be leveraged for attacks.
Weak_JWT_implementation: By inspecting the JSON Web Tokens (JWTs) used in the application for security flaws by checking if the tokens use weak algorithms (e.g., 'none' or 'HS256' with a weak secret), have long expiration times, or are improperly signed. Also Attempting token forgery or manipulation to bypass authentication or authorization.
Session_hijack: By capturing session tokens through methods such as XSS, MITM attacks, or insecure storage and using the captured token to hijack an active session and gain unauthorized access to the application.
Session_id_prediction: By analyzing the session IDs issued by the application for patterns or predictability and attempting to guess and brute-force valid session IDs.
Test_session_management_schema: By evaluating the session management practices of the application and checking for secure cookie attributes (e.g., HttpOnly, Secure, SameSite) and proper session expiration.
Session_fixation: By setting a session ID in advance (e.g., via a URL parameter or cookie) and checking if the application accepts and uses this session ID after login. By verifying if the session ID remains unchanged after authentication, potentially allowing an attacker to hijack the session.
Test_for_exposed_session_variables: By inspecting client-side storage mechanisms (e.g., cookies, local storage, session storage) for session-related variables and verifying if sensitive session information is exposed.
Session_timeout: By logging into the application and remaining idle for an extended period and then verifying if the session automatically expires and logs the user out after a certain period of inactivity, ensuring that sessions are not kept alive indefinitely.
Test_for_session_puzzling: By attempting to perform actions in an unintended order or concurrently to confuse the application's session handling logic and checking if this leads to unauthorized access or data corruption due to improper session state management.
Vulnerable_remember_password: By checking if the "Remember Me" functionality stores credentials or session tokens insecurely and verifying if sensitive information is stored in plaintext or with weak encryption in cookies or local storage, potentially exposing it to attackers.
Browser_cache_weakness: By inspecting the caching headers and behavior of the application and checking if sensitive data (e.g., session tokens, personal information) is cached by the browser, which could be accessed by other users or through local file access.
Nuclei_scan: By using Nuclei, a configurable vulnerability scanner, to scan the application. By creating or using existing templates to identify known vulnerabilities and misconfigurations in the application's infrastructure and code.
Burp_active_scan: By using Burp Suite's active scanning functionality to test the application for vulnerabilities. By configuring the scanner to thoroughly probe for common web application vulnerabilities, such as SQL injection, XSS, and insecure deserialization.
OWASP_ZAP_active_scan: By using OWASP ZAP's active scanning capabilities to assess the application's security. By running a comprehensive scan to identify issues like insecure authentication, broken access controls, and other OWASP Top 10 vulnerabilities.